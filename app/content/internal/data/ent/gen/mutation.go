// Code generated by ent, DO NOT EDIT.

package gen

import (
	"content/internal/data/ent/gen/article"
	"content/internal/data/ent/gen/articlelottery"
	"content/internal/data/ent/gen/articlelotteryparticipant"
	"content/internal/data/ent/gen/articlelotterywinner"
	"content/internal/data/ent/gen/articlepostscript"
	"content/internal/data/ent/gen/articlevote"
	"content/internal/data/ent/gen/articlevoterecord"
	"content/internal/data/ent/gen/comment"
	"content/internal/data/ent/gen/domain"
	"content/internal/data/ent/gen/predicate"
	"content/internal/data/ent/gen/tag"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeArticle                   = "Article"
	TypeArticleLottery            = "ArticleLottery"
	TypeArticleLotteryParticipant = "ArticleLotteryParticipant"
	TypeArticleLotteryWinner      = "ArticleLotteryWinner"
	TypeArticlePostscript         = "ArticlePostscript"
	TypeArticleVote               = "ArticleVote"
	TypeArticleVoteRecord         = "ArticleVoteRecord"
	TypeComment                   = "Comment"
	TypeDomain                    = "Domain"
	TypeTag                       = "Tag"
)

// ArticleMutation represents an operation that mutates the Article nodes in the graph.
type ArticleMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	user_id                      *string
	title                        *string
	content                      *string
	has_postscript               *bool
	reward_content               *string
	reward_points                *int
	addreward_points             *int
	status                       *int
	addstatus                    *int
	_type                        *int
	add_type                     *int
	commentable                  *bool
	anonymous                    *bool
	thank_count                  *int
	addthank_count               *int
	like_count                   *int
	addlike_count                *int
	dislike_count                *int
	adddislike_count             *int
	collect_count                *int
	addcollect_count             *int
	watch_count                  *int
	addwatch_count               *int
	bounty_points                *int
	addbounty_points             *int
	accepted_answer_id           *int
	addaccepted_answer_id        *int
	vote_total                   *int
	addvote_total                *int
	lottery_participant_count    *int
	addlottery_participant_count *int
	lottery_winner_count         *int
	addlottery_winner_count      *int
	created_at                   *time.Time
	updated_at                   *time.Time
	clearedFields                map[string]struct{}
	postscripts                  map[int]struct{}
	removedpostscripts           map[int]struct{}
	clearedpostscripts           bool
	votes                        map[int]struct{}
	removedvotes                 map[int]struct{}
	clearedvotes                 bool
	lotteries                    map[int]struct{}
	removedlotteries             map[int]struct{}
	clearedlotteries             bool
	comments                     map[int]struct{}
	removedcomments              map[int]struct{}
	clearedcomments              bool
	tags                         map[int]struct{}
	removedtags                  map[int]struct{}
	clearedtags                  bool
	done                         bool
	oldValue                     func(context.Context) (*Article, error)
	predicates                   []predicate.Article
}

var _ ent.Mutation = (*ArticleMutation)(nil)

// articleOption allows management of the mutation configuration using functional options.
type articleOption func(*ArticleMutation)

// newArticleMutation creates new mutation for the Article entity.
func newArticleMutation(c config, op Op, opts ...articleOption) *ArticleMutation {
	m := &ArticleMutation{
		config:        c,
		op:            op,
		typ:           TypeArticle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArticleID sets the ID field of the mutation.
func withArticleID(id int) articleOption {
	return func(m *ArticleMutation) {
		var (
			err   error
			once  sync.Once
			value *Article
		)
		m.oldValue = func(ctx context.Context) (*Article, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Article.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArticle sets the old Article of the mutation.
func withArticle(node *Article) articleOption {
	return func(m *ArticleMutation) {
		m.oldValue = func(context.Context) (*Article, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArticleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArticleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArticleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArticleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Article.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *ArticleMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ArticleMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ArticleMutation) ResetUserID() {
	m.user_id = nil
}

// SetTitle sets the "title" field.
func (m *ArticleMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ArticleMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ArticleMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *ArticleMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ArticleMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *ArticleMutation) ResetContent() {
	m.content = nil
}

// SetHasPostscript sets the "has_postscript" field.
func (m *ArticleMutation) SetHasPostscript(b bool) {
	m.has_postscript = &b
}

// HasPostscript returns the value of the "has_postscript" field in the mutation.
func (m *ArticleMutation) HasPostscript() (r bool, exists bool) {
	v := m.has_postscript
	if v == nil {
		return
	}
	return *v, true
}

// OldHasPostscript returns the old "has_postscript" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldHasPostscript(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasPostscript is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasPostscript requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasPostscript: %w", err)
	}
	return oldValue.HasPostscript, nil
}

// ResetHasPostscript resets all changes to the "has_postscript" field.
func (m *ArticleMutation) ResetHasPostscript() {
	m.has_postscript = nil
}

// SetRewardContent sets the "reward_content" field.
func (m *ArticleMutation) SetRewardContent(s string) {
	m.reward_content = &s
}

// RewardContent returns the value of the "reward_content" field in the mutation.
func (m *ArticleMutation) RewardContent() (r string, exists bool) {
	v := m.reward_content
	if v == nil {
		return
	}
	return *v, true
}

// OldRewardContent returns the old "reward_content" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldRewardContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRewardContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRewardContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRewardContent: %w", err)
	}
	return oldValue.RewardContent, nil
}

// ClearRewardContent clears the value of the "reward_content" field.
func (m *ArticleMutation) ClearRewardContent() {
	m.reward_content = nil
	m.clearedFields[article.FieldRewardContent] = struct{}{}
}

// RewardContentCleared returns if the "reward_content" field was cleared in this mutation.
func (m *ArticleMutation) RewardContentCleared() bool {
	_, ok := m.clearedFields[article.FieldRewardContent]
	return ok
}

// ResetRewardContent resets all changes to the "reward_content" field.
func (m *ArticleMutation) ResetRewardContent() {
	m.reward_content = nil
	delete(m.clearedFields, article.FieldRewardContent)
}

// SetRewardPoints sets the "reward_points" field.
func (m *ArticleMutation) SetRewardPoints(i int) {
	m.reward_points = &i
	m.addreward_points = nil
}

// RewardPoints returns the value of the "reward_points" field in the mutation.
func (m *ArticleMutation) RewardPoints() (r int, exists bool) {
	v := m.reward_points
	if v == nil {
		return
	}
	return *v, true
}

// OldRewardPoints returns the old "reward_points" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldRewardPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRewardPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRewardPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRewardPoints: %w", err)
	}
	return oldValue.RewardPoints, nil
}

// AddRewardPoints adds i to the "reward_points" field.
func (m *ArticleMutation) AddRewardPoints(i int) {
	if m.addreward_points != nil {
		*m.addreward_points += i
	} else {
		m.addreward_points = &i
	}
}

// AddedRewardPoints returns the value that was added to the "reward_points" field in this mutation.
func (m *ArticleMutation) AddedRewardPoints() (r int, exists bool) {
	v := m.addreward_points
	if v == nil {
		return
	}
	return *v, true
}

// ResetRewardPoints resets all changes to the "reward_points" field.
func (m *ArticleMutation) ResetRewardPoints() {
	m.reward_points = nil
	m.addreward_points = nil
}

// SetStatus sets the "status" field.
func (m *ArticleMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ArticleMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ArticleMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ArticleMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ArticleMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetType sets the "type" field.
func (m *ArticleMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *ArticleMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *ArticleMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *ArticleMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *ArticleMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetCommentable sets the "commentable" field.
func (m *ArticleMutation) SetCommentable(b bool) {
	m.commentable = &b
}

// Commentable returns the value of the "commentable" field in the mutation.
func (m *ArticleMutation) Commentable() (r bool, exists bool) {
	v := m.commentable
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentable returns the old "commentable" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldCommentable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentable: %w", err)
	}
	return oldValue.Commentable, nil
}

// ResetCommentable resets all changes to the "commentable" field.
func (m *ArticleMutation) ResetCommentable() {
	m.commentable = nil
}

// SetAnonymous sets the "anonymous" field.
func (m *ArticleMutation) SetAnonymous(b bool) {
	m.anonymous = &b
}

// Anonymous returns the value of the "anonymous" field in the mutation.
func (m *ArticleMutation) Anonymous() (r bool, exists bool) {
	v := m.anonymous
	if v == nil {
		return
	}
	return *v, true
}

// OldAnonymous returns the old "anonymous" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldAnonymous(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnonymous is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnonymous requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnonymous: %w", err)
	}
	return oldValue.Anonymous, nil
}

// ResetAnonymous resets all changes to the "anonymous" field.
func (m *ArticleMutation) ResetAnonymous() {
	m.anonymous = nil
}

// SetThankCount sets the "thank_count" field.
func (m *ArticleMutation) SetThankCount(i int) {
	m.thank_count = &i
	m.addthank_count = nil
}

// ThankCount returns the value of the "thank_count" field in the mutation.
func (m *ArticleMutation) ThankCount() (r int, exists bool) {
	v := m.thank_count
	if v == nil {
		return
	}
	return *v, true
}

// OldThankCount returns the old "thank_count" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldThankCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThankCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThankCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThankCount: %w", err)
	}
	return oldValue.ThankCount, nil
}

// AddThankCount adds i to the "thank_count" field.
func (m *ArticleMutation) AddThankCount(i int) {
	if m.addthank_count != nil {
		*m.addthank_count += i
	} else {
		m.addthank_count = &i
	}
}

// AddedThankCount returns the value that was added to the "thank_count" field in this mutation.
func (m *ArticleMutation) AddedThankCount() (r int, exists bool) {
	v := m.addthank_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetThankCount resets all changes to the "thank_count" field.
func (m *ArticleMutation) ResetThankCount() {
	m.thank_count = nil
	m.addthank_count = nil
}

// SetLikeCount sets the "like_count" field.
func (m *ArticleMutation) SetLikeCount(i int) {
	m.like_count = &i
	m.addlike_count = nil
}

// LikeCount returns the value of the "like_count" field in the mutation.
func (m *ArticleMutation) LikeCount() (r int, exists bool) {
	v := m.like_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeCount returns the old "like_count" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldLikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeCount: %w", err)
	}
	return oldValue.LikeCount, nil
}

// AddLikeCount adds i to the "like_count" field.
func (m *ArticleMutation) AddLikeCount(i int) {
	if m.addlike_count != nil {
		*m.addlike_count += i
	} else {
		m.addlike_count = &i
	}
}

// AddedLikeCount returns the value that was added to the "like_count" field in this mutation.
func (m *ArticleMutation) AddedLikeCount() (r int, exists bool) {
	v := m.addlike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikeCount resets all changes to the "like_count" field.
func (m *ArticleMutation) ResetLikeCount() {
	m.like_count = nil
	m.addlike_count = nil
}

// SetDislikeCount sets the "dislike_count" field.
func (m *ArticleMutation) SetDislikeCount(i int) {
	m.dislike_count = &i
	m.adddislike_count = nil
}

// DislikeCount returns the value of the "dislike_count" field in the mutation.
func (m *ArticleMutation) DislikeCount() (r int, exists bool) {
	v := m.dislike_count
	if v == nil {
		return
	}
	return *v, true
}

// OldDislikeCount returns the old "dislike_count" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldDislikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDislikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDislikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDislikeCount: %w", err)
	}
	return oldValue.DislikeCount, nil
}

// AddDislikeCount adds i to the "dislike_count" field.
func (m *ArticleMutation) AddDislikeCount(i int) {
	if m.adddislike_count != nil {
		*m.adddislike_count += i
	} else {
		m.adddislike_count = &i
	}
}

// AddedDislikeCount returns the value that was added to the "dislike_count" field in this mutation.
func (m *ArticleMutation) AddedDislikeCount() (r int, exists bool) {
	v := m.adddislike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetDislikeCount resets all changes to the "dislike_count" field.
func (m *ArticleMutation) ResetDislikeCount() {
	m.dislike_count = nil
	m.adddislike_count = nil
}

// SetCollectCount sets the "collect_count" field.
func (m *ArticleMutation) SetCollectCount(i int) {
	m.collect_count = &i
	m.addcollect_count = nil
}

// CollectCount returns the value of the "collect_count" field in the mutation.
func (m *ArticleMutation) CollectCount() (r int, exists bool) {
	v := m.collect_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectCount returns the old "collect_count" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldCollectCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectCount: %w", err)
	}
	return oldValue.CollectCount, nil
}

// AddCollectCount adds i to the "collect_count" field.
func (m *ArticleMutation) AddCollectCount(i int) {
	if m.addcollect_count != nil {
		*m.addcollect_count += i
	} else {
		m.addcollect_count = &i
	}
}

// AddedCollectCount returns the value that was added to the "collect_count" field in this mutation.
func (m *ArticleMutation) AddedCollectCount() (r int, exists bool) {
	v := m.addcollect_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCollectCount resets all changes to the "collect_count" field.
func (m *ArticleMutation) ResetCollectCount() {
	m.collect_count = nil
	m.addcollect_count = nil
}

// SetWatchCount sets the "watch_count" field.
func (m *ArticleMutation) SetWatchCount(i int) {
	m.watch_count = &i
	m.addwatch_count = nil
}

// WatchCount returns the value of the "watch_count" field in the mutation.
func (m *ArticleMutation) WatchCount() (r int, exists bool) {
	v := m.watch_count
	if v == nil {
		return
	}
	return *v, true
}

// OldWatchCount returns the old "watch_count" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldWatchCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWatchCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWatchCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWatchCount: %w", err)
	}
	return oldValue.WatchCount, nil
}

// AddWatchCount adds i to the "watch_count" field.
func (m *ArticleMutation) AddWatchCount(i int) {
	if m.addwatch_count != nil {
		*m.addwatch_count += i
	} else {
		m.addwatch_count = &i
	}
}

// AddedWatchCount returns the value that was added to the "watch_count" field in this mutation.
func (m *ArticleMutation) AddedWatchCount() (r int, exists bool) {
	v := m.addwatch_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetWatchCount resets all changes to the "watch_count" field.
func (m *ArticleMutation) ResetWatchCount() {
	m.watch_count = nil
	m.addwatch_count = nil
}

// SetBountyPoints sets the "bounty_points" field.
func (m *ArticleMutation) SetBountyPoints(i int) {
	m.bounty_points = &i
	m.addbounty_points = nil
}

// BountyPoints returns the value of the "bounty_points" field in the mutation.
func (m *ArticleMutation) BountyPoints() (r int, exists bool) {
	v := m.bounty_points
	if v == nil {
		return
	}
	return *v, true
}

// OldBountyPoints returns the old "bounty_points" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldBountyPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBountyPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBountyPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBountyPoints: %w", err)
	}
	return oldValue.BountyPoints, nil
}

// AddBountyPoints adds i to the "bounty_points" field.
func (m *ArticleMutation) AddBountyPoints(i int) {
	if m.addbounty_points != nil {
		*m.addbounty_points += i
	} else {
		m.addbounty_points = &i
	}
}

// AddedBountyPoints returns the value that was added to the "bounty_points" field in this mutation.
func (m *ArticleMutation) AddedBountyPoints() (r int, exists bool) {
	v := m.addbounty_points
	if v == nil {
		return
	}
	return *v, true
}

// ResetBountyPoints resets all changes to the "bounty_points" field.
func (m *ArticleMutation) ResetBountyPoints() {
	m.bounty_points = nil
	m.addbounty_points = nil
}

// SetAcceptedAnswerID sets the "accepted_answer_id" field.
func (m *ArticleMutation) SetAcceptedAnswerID(i int) {
	m.accepted_answer_id = &i
	m.addaccepted_answer_id = nil
}

// AcceptedAnswerID returns the value of the "accepted_answer_id" field in the mutation.
func (m *ArticleMutation) AcceptedAnswerID() (r int, exists bool) {
	v := m.accepted_answer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAcceptedAnswerID returns the old "accepted_answer_id" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldAcceptedAnswerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcceptedAnswerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcceptedAnswerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcceptedAnswerID: %w", err)
	}
	return oldValue.AcceptedAnswerID, nil
}

// AddAcceptedAnswerID adds i to the "accepted_answer_id" field.
func (m *ArticleMutation) AddAcceptedAnswerID(i int) {
	if m.addaccepted_answer_id != nil {
		*m.addaccepted_answer_id += i
	} else {
		m.addaccepted_answer_id = &i
	}
}

// AddedAcceptedAnswerID returns the value that was added to the "accepted_answer_id" field in this mutation.
func (m *ArticleMutation) AddedAcceptedAnswerID() (r int, exists bool) {
	v := m.addaccepted_answer_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAcceptedAnswerID clears the value of the "accepted_answer_id" field.
func (m *ArticleMutation) ClearAcceptedAnswerID() {
	m.accepted_answer_id = nil
	m.addaccepted_answer_id = nil
	m.clearedFields[article.FieldAcceptedAnswerID] = struct{}{}
}

// AcceptedAnswerIDCleared returns if the "accepted_answer_id" field was cleared in this mutation.
func (m *ArticleMutation) AcceptedAnswerIDCleared() bool {
	_, ok := m.clearedFields[article.FieldAcceptedAnswerID]
	return ok
}

// ResetAcceptedAnswerID resets all changes to the "accepted_answer_id" field.
func (m *ArticleMutation) ResetAcceptedAnswerID() {
	m.accepted_answer_id = nil
	m.addaccepted_answer_id = nil
	delete(m.clearedFields, article.FieldAcceptedAnswerID)
}

// SetVoteTotal sets the "vote_total" field.
func (m *ArticleMutation) SetVoteTotal(i int) {
	m.vote_total = &i
	m.addvote_total = nil
}

// VoteTotal returns the value of the "vote_total" field in the mutation.
func (m *ArticleMutation) VoteTotal() (r int, exists bool) {
	v := m.vote_total
	if v == nil {
		return
	}
	return *v, true
}

// OldVoteTotal returns the old "vote_total" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldVoteTotal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoteTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoteTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoteTotal: %w", err)
	}
	return oldValue.VoteTotal, nil
}

// AddVoteTotal adds i to the "vote_total" field.
func (m *ArticleMutation) AddVoteTotal(i int) {
	if m.addvote_total != nil {
		*m.addvote_total += i
	} else {
		m.addvote_total = &i
	}
}

// AddedVoteTotal returns the value that was added to the "vote_total" field in this mutation.
func (m *ArticleMutation) AddedVoteTotal() (r int, exists bool) {
	v := m.addvote_total
	if v == nil {
		return
	}
	return *v, true
}

// ResetVoteTotal resets all changes to the "vote_total" field.
func (m *ArticleMutation) ResetVoteTotal() {
	m.vote_total = nil
	m.addvote_total = nil
}

// SetLotteryParticipantCount sets the "lottery_participant_count" field.
func (m *ArticleMutation) SetLotteryParticipantCount(i int) {
	m.lottery_participant_count = &i
	m.addlottery_participant_count = nil
}

// LotteryParticipantCount returns the value of the "lottery_participant_count" field in the mutation.
func (m *ArticleMutation) LotteryParticipantCount() (r int, exists bool) {
	v := m.lottery_participant_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLotteryParticipantCount returns the old "lottery_participant_count" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldLotteryParticipantCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLotteryParticipantCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLotteryParticipantCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLotteryParticipantCount: %w", err)
	}
	return oldValue.LotteryParticipantCount, nil
}

// AddLotteryParticipantCount adds i to the "lottery_participant_count" field.
func (m *ArticleMutation) AddLotteryParticipantCount(i int) {
	if m.addlottery_participant_count != nil {
		*m.addlottery_participant_count += i
	} else {
		m.addlottery_participant_count = &i
	}
}

// AddedLotteryParticipantCount returns the value that was added to the "lottery_participant_count" field in this mutation.
func (m *ArticleMutation) AddedLotteryParticipantCount() (r int, exists bool) {
	v := m.addlottery_participant_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLotteryParticipantCount resets all changes to the "lottery_participant_count" field.
func (m *ArticleMutation) ResetLotteryParticipantCount() {
	m.lottery_participant_count = nil
	m.addlottery_participant_count = nil
}

// SetLotteryWinnerCount sets the "lottery_winner_count" field.
func (m *ArticleMutation) SetLotteryWinnerCount(i int) {
	m.lottery_winner_count = &i
	m.addlottery_winner_count = nil
}

// LotteryWinnerCount returns the value of the "lottery_winner_count" field in the mutation.
func (m *ArticleMutation) LotteryWinnerCount() (r int, exists bool) {
	v := m.lottery_winner_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLotteryWinnerCount returns the old "lottery_winner_count" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldLotteryWinnerCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLotteryWinnerCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLotteryWinnerCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLotteryWinnerCount: %w", err)
	}
	return oldValue.LotteryWinnerCount, nil
}

// AddLotteryWinnerCount adds i to the "lottery_winner_count" field.
func (m *ArticleMutation) AddLotteryWinnerCount(i int) {
	if m.addlottery_winner_count != nil {
		*m.addlottery_winner_count += i
	} else {
		m.addlottery_winner_count = &i
	}
}

// AddedLotteryWinnerCount returns the value that was added to the "lottery_winner_count" field in this mutation.
func (m *ArticleMutation) AddedLotteryWinnerCount() (r int, exists bool) {
	v := m.addlottery_winner_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLotteryWinnerCount resets all changes to the "lottery_winner_count" field.
func (m *ArticleMutation) ResetLotteryWinnerCount() {
	m.lottery_winner_count = nil
	m.addlottery_winner_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ArticleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArticleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArticleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArticleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArticleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArticleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddPostscriptIDs adds the "postscripts" edge to the ArticlePostscript entity by ids.
func (m *ArticleMutation) AddPostscriptIDs(ids ...int) {
	if m.postscripts == nil {
		m.postscripts = make(map[int]struct{})
	}
	for i := range ids {
		m.postscripts[ids[i]] = struct{}{}
	}
}

// ClearPostscripts clears the "postscripts" edge to the ArticlePostscript entity.
func (m *ArticleMutation) ClearPostscripts() {
	m.clearedpostscripts = true
}

// PostscriptsCleared reports if the "postscripts" edge to the ArticlePostscript entity was cleared.
func (m *ArticleMutation) PostscriptsCleared() bool {
	return m.clearedpostscripts
}

// RemovePostscriptIDs removes the "postscripts" edge to the ArticlePostscript entity by IDs.
func (m *ArticleMutation) RemovePostscriptIDs(ids ...int) {
	if m.removedpostscripts == nil {
		m.removedpostscripts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.postscripts, ids[i])
		m.removedpostscripts[ids[i]] = struct{}{}
	}
}

// RemovedPostscripts returns the removed IDs of the "postscripts" edge to the ArticlePostscript entity.
func (m *ArticleMutation) RemovedPostscriptsIDs() (ids []int) {
	for id := range m.removedpostscripts {
		ids = append(ids, id)
	}
	return
}

// PostscriptsIDs returns the "postscripts" edge IDs in the mutation.
func (m *ArticleMutation) PostscriptsIDs() (ids []int) {
	for id := range m.postscripts {
		ids = append(ids, id)
	}
	return
}

// ResetPostscripts resets all changes to the "postscripts" edge.
func (m *ArticleMutation) ResetPostscripts() {
	m.postscripts = nil
	m.clearedpostscripts = false
	m.removedpostscripts = nil
}

// AddVoteIDs adds the "votes" edge to the ArticleVote entity by ids.
func (m *ArticleMutation) AddVoteIDs(ids ...int) {
	if m.votes == nil {
		m.votes = make(map[int]struct{})
	}
	for i := range ids {
		m.votes[ids[i]] = struct{}{}
	}
}

// ClearVotes clears the "votes" edge to the ArticleVote entity.
func (m *ArticleMutation) ClearVotes() {
	m.clearedvotes = true
}

// VotesCleared reports if the "votes" edge to the ArticleVote entity was cleared.
func (m *ArticleMutation) VotesCleared() bool {
	return m.clearedvotes
}

// RemoveVoteIDs removes the "votes" edge to the ArticleVote entity by IDs.
func (m *ArticleMutation) RemoveVoteIDs(ids ...int) {
	if m.removedvotes == nil {
		m.removedvotes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.votes, ids[i])
		m.removedvotes[ids[i]] = struct{}{}
	}
}

// RemovedVotes returns the removed IDs of the "votes" edge to the ArticleVote entity.
func (m *ArticleMutation) RemovedVotesIDs() (ids []int) {
	for id := range m.removedvotes {
		ids = append(ids, id)
	}
	return
}

// VotesIDs returns the "votes" edge IDs in the mutation.
func (m *ArticleMutation) VotesIDs() (ids []int) {
	for id := range m.votes {
		ids = append(ids, id)
	}
	return
}

// ResetVotes resets all changes to the "votes" edge.
func (m *ArticleMutation) ResetVotes() {
	m.votes = nil
	m.clearedvotes = false
	m.removedvotes = nil
}

// AddLotteryIDs adds the "lotteries" edge to the ArticleLottery entity by ids.
func (m *ArticleMutation) AddLotteryIDs(ids ...int) {
	if m.lotteries == nil {
		m.lotteries = make(map[int]struct{})
	}
	for i := range ids {
		m.lotteries[ids[i]] = struct{}{}
	}
}

// ClearLotteries clears the "lotteries" edge to the ArticleLottery entity.
func (m *ArticleMutation) ClearLotteries() {
	m.clearedlotteries = true
}

// LotteriesCleared reports if the "lotteries" edge to the ArticleLottery entity was cleared.
func (m *ArticleMutation) LotteriesCleared() bool {
	return m.clearedlotteries
}

// RemoveLotteryIDs removes the "lotteries" edge to the ArticleLottery entity by IDs.
func (m *ArticleMutation) RemoveLotteryIDs(ids ...int) {
	if m.removedlotteries == nil {
		m.removedlotteries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.lotteries, ids[i])
		m.removedlotteries[ids[i]] = struct{}{}
	}
}

// RemovedLotteries returns the removed IDs of the "lotteries" edge to the ArticleLottery entity.
func (m *ArticleMutation) RemovedLotteriesIDs() (ids []int) {
	for id := range m.removedlotteries {
		ids = append(ids, id)
	}
	return
}

// LotteriesIDs returns the "lotteries" edge IDs in the mutation.
func (m *ArticleMutation) LotteriesIDs() (ids []int) {
	for id := range m.lotteries {
		ids = append(ids, id)
	}
	return
}

// ResetLotteries resets all changes to the "lotteries" edge.
func (m *ArticleMutation) ResetLotteries() {
	m.lotteries = nil
	m.clearedlotteries = false
	m.removedlotteries = nil
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *ArticleMutation) AddCommentIDs(ids ...int) {
	if m.comments == nil {
		m.comments = make(map[int]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *ArticleMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *ArticleMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *ArticleMutation) RemoveCommentIDs(ids ...int) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *ArticleMutation) RemovedCommentsIDs() (ids []int) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *ArticleMutation) CommentsIDs() (ids []int) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *ArticleMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *ArticleMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *ArticleMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *ArticleMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *ArticleMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *ArticleMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *ArticleMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *ArticleMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// Where appends a list predicates to the ArticleMutation builder.
func (m *ArticleMutation) Where(ps ...predicate.Article) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArticleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArticleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Article, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArticleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArticleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Article).
func (m *ArticleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArticleMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.user_id != nil {
		fields = append(fields, article.FieldUserID)
	}
	if m.title != nil {
		fields = append(fields, article.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, article.FieldContent)
	}
	if m.has_postscript != nil {
		fields = append(fields, article.FieldHasPostscript)
	}
	if m.reward_content != nil {
		fields = append(fields, article.FieldRewardContent)
	}
	if m.reward_points != nil {
		fields = append(fields, article.FieldRewardPoints)
	}
	if m.status != nil {
		fields = append(fields, article.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, article.FieldType)
	}
	if m.commentable != nil {
		fields = append(fields, article.FieldCommentable)
	}
	if m.anonymous != nil {
		fields = append(fields, article.FieldAnonymous)
	}
	if m.thank_count != nil {
		fields = append(fields, article.FieldThankCount)
	}
	if m.like_count != nil {
		fields = append(fields, article.FieldLikeCount)
	}
	if m.dislike_count != nil {
		fields = append(fields, article.FieldDislikeCount)
	}
	if m.collect_count != nil {
		fields = append(fields, article.FieldCollectCount)
	}
	if m.watch_count != nil {
		fields = append(fields, article.FieldWatchCount)
	}
	if m.bounty_points != nil {
		fields = append(fields, article.FieldBountyPoints)
	}
	if m.accepted_answer_id != nil {
		fields = append(fields, article.FieldAcceptedAnswerID)
	}
	if m.vote_total != nil {
		fields = append(fields, article.FieldVoteTotal)
	}
	if m.lottery_participant_count != nil {
		fields = append(fields, article.FieldLotteryParticipantCount)
	}
	if m.lottery_winner_count != nil {
		fields = append(fields, article.FieldLotteryWinnerCount)
	}
	if m.created_at != nil {
		fields = append(fields, article.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, article.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArticleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case article.FieldUserID:
		return m.UserID()
	case article.FieldTitle:
		return m.Title()
	case article.FieldContent:
		return m.Content()
	case article.FieldHasPostscript:
		return m.HasPostscript()
	case article.FieldRewardContent:
		return m.RewardContent()
	case article.FieldRewardPoints:
		return m.RewardPoints()
	case article.FieldStatus:
		return m.Status()
	case article.FieldType:
		return m.GetType()
	case article.FieldCommentable:
		return m.Commentable()
	case article.FieldAnonymous:
		return m.Anonymous()
	case article.FieldThankCount:
		return m.ThankCount()
	case article.FieldLikeCount:
		return m.LikeCount()
	case article.FieldDislikeCount:
		return m.DislikeCount()
	case article.FieldCollectCount:
		return m.CollectCount()
	case article.FieldWatchCount:
		return m.WatchCount()
	case article.FieldBountyPoints:
		return m.BountyPoints()
	case article.FieldAcceptedAnswerID:
		return m.AcceptedAnswerID()
	case article.FieldVoteTotal:
		return m.VoteTotal()
	case article.FieldLotteryParticipantCount:
		return m.LotteryParticipantCount()
	case article.FieldLotteryWinnerCount:
		return m.LotteryWinnerCount()
	case article.FieldCreatedAt:
		return m.CreatedAt()
	case article.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArticleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case article.FieldUserID:
		return m.OldUserID(ctx)
	case article.FieldTitle:
		return m.OldTitle(ctx)
	case article.FieldContent:
		return m.OldContent(ctx)
	case article.FieldHasPostscript:
		return m.OldHasPostscript(ctx)
	case article.FieldRewardContent:
		return m.OldRewardContent(ctx)
	case article.FieldRewardPoints:
		return m.OldRewardPoints(ctx)
	case article.FieldStatus:
		return m.OldStatus(ctx)
	case article.FieldType:
		return m.OldType(ctx)
	case article.FieldCommentable:
		return m.OldCommentable(ctx)
	case article.FieldAnonymous:
		return m.OldAnonymous(ctx)
	case article.FieldThankCount:
		return m.OldThankCount(ctx)
	case article.FieldLikeCount:
		return m.OldLikeCount(ctx)
	case article.FieldDislikeCount:
		return m.OldDislikeCount(ctx)
	case article.FieldCollectCount:
		return m.OldCollectCount(ctx)
	case article.FieldWatchCount:
		return m.OldWatchCount(ctx)
	case article.FieldBountyPoints:
		return m.OldBountyPoints(ctx)
	case article.FieldAcceptedAnswerID:
		return m.OldAcceptedAnswerID(ctx)
	case article.FieldVoteTotal:
		return m.OldVoteTotal(ctx)
	case article.FieldLotteryParticipantCount:
		return m.OldLotteryParticipantCount(ctx)
	case article.FieldLotteryWinnerCount:
		return m.OldLotteryWinnerCount(ctx)
	case article.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case article.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Article field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArticleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case article.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case article.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case article.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case article.FieldHasPostscript:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasPostscript(v)
		return nil
	case article.FieldRewardContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRewardContent(v)
		return nil
	case article.FieldRewardPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRewardPoints(v)
		return nil
	case article.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case article.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case article.FieldCommentable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentable(v)
		return nil
	case article.FieldAnonymous:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnonymous(v)
		return nil
	case article.FieldThankCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThankCount(v)
		return nil
	case article.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeCount(v)
		return nil
	case article.FieldDislikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDislikeCount(v)
		return nil
	case article.FieldCollectCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectCount(v)
		return nil
	case article.FieldWatchCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWatchCount(v)
		return nil
	case article.FieldBountyPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBountyPoints(v)
		return nil
	case article.FieldAcceptedAnswerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcceptedAnswerID(v)
		return nil
	case article.FieldVoteTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoteTotal(v)
		return nil
	case article.FieldLotteryParticipantCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLotteryParticipantCount(v)
		return nil
	case article.FieldLotteryWinnerCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLotteryWinnerCount(v)
		return nil
	case article.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case article.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Article field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArticleMutation) AddedFields() []string {
	var fields []string
	if m.addreward_points != nil {
		fields = append(fields, article.FieldRewardPoints)
	}
	if m.addstatus != nil {
		fields = append(fields, article.FieldStatus)
	}
	if m.add_type != nil {
		fields = append(fields, article.FieldType)
	}
	if m.addthank_count != nil {
		fields = append(fields, article.FieldThankCount)
	}
	if m.addlike_count != nil {
		fields = append(fields, article.FieldLikeCount)
	}
	if m.adddislike_count != nil {
		fields = append(fields, article.FieldDislikeCount)
	}
	if m.addcollect_count != nil {
		fields = append(fields, article.FieldCollectCount)
	}
	if m.addwatch_count != nil {
		fields = append(fields, article.FieldWatchCount)
	}
	if m.addbounty_points != nil {
		fields = append(fields, article.FieldBountyPoints)
	}
	if m.addaccepted_answer_id != nil {
		fields = append(fields, article.FieldAcceptedAnswerID)
	}
	if m.addvote_total != nil {
		fields = append(fields, article.FieldVoteTotal)
	}
	if m.addlottery_participant_count != nil {
		fields = append(fields, article.FieldLotteryParticipantCount)
	}
	if m.addlottery_winner_count != nil {
		fields = append(fields, article.FieldLotteryWinnerCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArticleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case article.FieldRewardPoints:
		return m.AddedRewardPoints()
	case article.FieldStatus:
		return m.AddedStatus()
	case article.FieldType:
		return m.AddedType()
	case article.FieldThankCount:
		return m.AddedThankCount()
	case article.FieldLikeCount:
		return m.AddedLikeCount()
	case article.FieldDislikeCount:
		return m.AddedDislikeCount()
	case article.FieldCollectCount:
		return m.AddedCollectCount()
	case article.FieldWatchCount:
		return m.AddedWatchCount()
	case article.FieldBountyPoints:
		return m.AddedBountyPoints()
	case article.FieldAcceptedAnswerID:
		return m.AddedAcceptedAnswerID()
	case article.FieldVoteTotal:
		return m.AddedVoteTotal()
	case article.FieldLotteryParticipantCount:
		return m.AddedLotteryParticipantCount()
	case article.FieldLotteryWinnerCount:
		return m.AddedLotteryWinnerCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArticleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case article.FieldRewardPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRewardPoints(v)
		return nil
	case article.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case article.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case article.FieldThankCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThankCount(v)
		return nil
	case article.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikeCount(v)
		return nil
	case article.FieldDislikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDislikeCount(v)
		return nil
	case article.FieldCollectCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCollectCount(v)
		return nil
	case article.FieldWatchCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWatchCount(v)
		return nil
	case article.FieldBountyPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBountyPoints(v)
		return nil
	case article.FieldAcceptedAnswerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAcceptedAnswerID(v)
		return nil
	case article.FieldVoteTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVoteTotal(v)
		return nil
	case article.FieldLotteryParticipantCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLotteryParticipantCount(v)
		return nil
	case article.FieldLotteryWinnerCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLotteryWinnerCount(v)
		return nil
	}
	return fmt.Errorf("unknown Article numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArticleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(article.FieldRewardContent) {
		fields = append(fields, article.FieldRewardContent)
	}
	if m.FieldCleared(article.FieldAcceptedAnswerID) {
		fields = append(fields, article.FieldAcceptedAnswerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArticleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArticleMutation) ClearField(name string) error {
	switch name {
	case article.FieldRewardContent:
		m.ClearRewardContent()
		return nil
	case article.FieldAcceptedAnswerID:
		m.ClearAcceptedAnswerID()
		return nil
	}
	return fmt.Errorf("unknown Article nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArticleMutation) ResetField(name string) error {
	switch name {
	case article.FieldUserID:
		m.ResetUserID()
		return nil
	case article.FieldTitle:
		m.ResetTitle()
		return nil
	case article.FieldContent:
		m.ResetContent()
		return nil
	case article.FieldHasPostscript:
		m.ResetHasPostscript()
		return nil
	case article.FieldRewardContent:
		m.ResetRewardContent()
		return nil
	case article.FieldRewardPoints:
		m.ResetRewardPoints()
		return nil
	case article.FieldStatus:
		m.ResetStatus()
		return nil
	case article.FieldType:
		m.ResetType()
		return nil
	case article.FieldCommentable:
		m.ResetCommentable()
		return nil
	case article.FieldAnonymous:
		m.ResetAnonymous()
		return nil
	case article.FieldThankCount:
		m.ResetThankCount()
		return nil
	case article.FieldLikeCount:
		m.ResetLikeCount()
		return nil
	case article.FieldDislikeCount:
		m.ResetDislikeCount()
		return nil
	case article.FieldCollectCount:
		m.ResetCollectCount()
		return nil
	case article.FieldWatchCount:
		m.ResetWatchCount()
		return nil
	case article.FieldBountyPoints:
		m.ResetBountyPoints()
		return nil
	case article.FieldAcceptedAnswerID:
		m.ResetAcceptedAnswerID()
		return nil
	case article.FieldVoteTotal:
		m.ResetVoteTotal()
		return nil
	case article.FieldLotteryParticipantCount:
		m.ResetLotteryParticipantCount()
		return nil
	case article.FieldLotteryWinnerCount:
		m.ResetLotteryWinnerCount()
		return nil
	case article.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case article.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Article field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArticleMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.postscripts != nil {
		edges = append(edges, article.EdgePostscripts)
	}
	if m.votes != nil {
		edges = append(edges, article.EdgeVotes)
	}
	if m.lotteries != nil {
		edges = append(edges, article.EdgeLotteries)
	}
	if m.comments != nil {
		edges = append(edges, article.EdgeComments)
	}
	if m.tags != nil {
		edges = append(edges, article.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArticleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case article.EdgePostscripts:
		ids := make([]ent.Value, 0, len(m.postscripts))
		for id := range m.postscripts {
			ids = append(ids, id)
		}
		return ids
	case article.EdgeVotes:
		ids := make([]ent.Value, 0, len(m.votes))
		for id := range m.votes {
			ids = append(ids, id)
		}
		return ids
	case article.EdgeLotteries:
		ids := make([]ent.Value, 0, len(m.lotteries))
		for id := range m.lotteries {
			ids = append(ids, id)
		}
		return ids
	case article.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case article.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArticleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedpostscripts != nil {
		edges = append(edges, article.EdgePostscripts)
	}
	if m.removedvotes != nil {
		edges = append(edges, article.EdgeVotes)
	}
	if m.removedlotteries != nil {
		edges = append(edges, article.EdgeLotteries)
	}
	if m.removedcomments != nil {
		edges = append(edges, article.EdgeComments)
	}
	if m.removedtags != nil {
		edges = append(edges, article.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArticleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case article.EdgePostscripts:
		ids := make([]ent.Value, 0, len(m.removedpostscripts))
		for id := range m.removedpostscripts {
			ids = append(ids, id)
		}
		return ids
	case article.EdgeVotes:
		ids := make([]ent.Value, 0, len(m.removedvotes))
		for id := range m.removedvotes {
			ids = append(ids, id)
		}
		return ids
	case article.EdgeLotteries:
		ids := make([]ent.Value, 0, len(m.removedlotteries))
		for id := range m.removedlotteries {
			ids = append(ids, id)
		}
		return ids
	case article.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case article.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArticleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedpostscripts {
		edges = append(edges, article.EdgePostscripts)
	}
	if m.clearedvotes {
		edges = append(edges, article.EdgeVotes)
	}
	if m.clearedlotteries {
		edges = append(edges, article.EdgeLotteries)
	}
	if m.clearedcomments {
		edges = append(edges, article.EdgeComments)
	}
	if m.clearedtags {
		edges = append(edges, article.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArticleMutation) EdgeCleared(name string) bool {
	switch name {
	case article.EdgePostscripts:
		return m.clearedpostscripts
	case article.EdgeVotes:
		return m.clearedvotes
	case article.EdgeLotteries:
		return m.clearedlotteries
	case article.EdgeComments:
		return m.clearedcomments
	case article.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArticleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Article unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArticleMutation) ResetEdge(name string) error {
	switch name {
	case article.EdgePostscripts:
		m.ResetPostscripts()
		return nil
	case article.EdgeVotes:
		m.ResetVotes()
		return nil
	case article.EdgeLotteries:
		m.ResetLotteries()
		return nil
	case article.EdgeComments:
		m.ResetComments()
		return nil
	case article.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Article edge %s", name)
}

// ArticleLotteryMutation represents an operation that mutates the ArticleLottery nodes in the graph.
type ArticleLotteryMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	prizes              *[]string
	appendprizes        []string
	start_at            *time.Time
	end_at              *time.Time
	status              *int
	addstatus           *int
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	article             *int
	clearedarticle      bool
	participants        map[int]struct{}
	removedparticipants map[int]struct{}
	clearedparticipants bool
	winners             map[int]struct{}
	removedwinners      map[int]struct{}
	clearedwinners      bool
	done                bool
	oldValue            func(context.Context) (*ArticleLottery, error)
	predicates          []predicate.ArticleLottery
}

var _ ent.Mutation = (*ArticleLotteryMutation)(nil)

// articlelotteryOption allows management of the mutation configuration using functional options.
type articlelotteryOption func(*ArticleLotteryMutation)

// newArticleLotteryMutation creates new mutation for the ArticleLottery entity.
func newArticleLotteryMutation(c config, op Op, opts ...articlelotteryOption) *ArticleLotteryMutation {
	m := &ArticleLotteryMutation{
		config:        c,
		op:            op,
		typ:           TypeArticleLottery,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArticleLotteryID sets the ID field of the mutation.
func withArticleLotteryID(id int) articlelotteryOption {
	return func(m *ArticleLotteryMutation) {
		var (
			err   error
			once  sync.Once
			value *ArticleLottery
		)
		m.oldValue = func(ctx context.Context) (*ArticleLottery, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ArticleLottery.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArticleLottery sets the old ArticleLottery of the mutation.
func withArticleLottery(node *ArticleLottery) articlelotteryOption {
	return func(m *ArticleLotteryMutation) {
		m.oldValue = func(context.Context) (*ArticleLottery, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArticleLotteryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArticleLotteryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArticleLotteryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArticleLotteryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ArticleLottery.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArticleID sets the "article_id" field.
func (m *ArticleLotteryMutation) SetArticleID(i int) {
	m.article = &i
}

// ArticleID returns the value of the "article_id" field in the mutation.
func (m *ArticleLotteryMutation) ArticleID() (r int, exists bool) {
	v := m.article
	if v == nil {
		return
	}
	return *v, true
}

// OldArticleID returns the old "article_id" field's value of the ArticleLottery entity.
// If the ArticleLottery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleLotteryMutation) OldArticleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArticleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArticleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArticleID: %w", err)
	}
	return oldValue.ArticleID, nil
}

// ResetArticleID resets all changes to the "article_id" field.
func (m *ArticleLotteryMutation) ResetArticleID() {
	m.article = nil
}

// SetPrizes sets the "prizes" field.
func (m *ArticleLotteryMutation) SetPrizes(s []string) {
	m.prizes = &s
	m.appendprizes = nil
}

// Prizes returns the value of the "prizes" field in the mutation.
func (m *ArticleLotteryMutation) Prizes() (r []string, exists bool) {
	v := m.prizes
	if v == nil {
		return
	}
	return *v, true
}

// OldPrizes returns the old "prizes" field's value of the ArticleLottery entity.
// If the ArticleLottery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleLotteryMutation) OldPrizes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrizes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrizes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrizes: %w", err)
	}
	return oldValue.Prizes, nil
}

// AppendPrizes adds s to the "prizes" field.
func (m *ArticleLotteryMutation) AppendPrizes(s []string) {
	m.appendprizes = append(m.appendprizes, s...)
}

// AppendedPrizes returns the list of values that were appended to the "prizes" field in this mutation.
func (m *ArticleLotteryMutation) AppendedPrizes() ([]string, bool) {
	if len(m.appendprizes) == 0 {
		return nil, false
	}
	return m.appendprizes, true
}

// ClearPrizes clears the value of the "prizes" field.
func (m *ArticleLotteryMutation) ClearPrizes() {
	m.prizes = nil
	m.appendprizes = nil
	m.clearedFields[articlelottery.FieldPrizes] = struct{}{}
}

// PrizesCleared returns if the "prizes" field was cleared in this mutation.
func (m *ArticleLotteryMutation) PrizesCleared() bool {
	_, ok := m.clearedFields[articlelottery.FieldPrizes]
	return ok
}

// ResetPrizes resets all changes to the "prizes" field.
func (m *ArticleLotteryMutation) ResetPrizes() {
	m.prizes = nil
	m.appendprizes = nil
	delete(m.clearedFields, articlelottery.FieldPrizes)
}

// SetStartAt sets the "start_at" field.
func (m *ArticleLotteryMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *ArticleLotteryMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the ArticleLottery entity.
// If the ArticleLottery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleLotteryMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *ArticleLotteryMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[articlelottery.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *ArticleLotteryMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[articlelottery.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *ArticleLotteryMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, articlelottery.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *ArticleLotteryMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *ArticleLotteryMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the ArticleLottery entity.
// If the ArticleLottery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleLotteryMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *ArticleLotteryMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[articlelottery.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *ArticleLotteryMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[articlelottery.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *ArticleLotteryMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, articlelottery.FieldEndAt)
}

// SetStatus sets the "status" field.
func (m *ArticleLotteryMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ArticleLotteryMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ArticleLottery entity.
// If the ArticleLottery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleLotteryMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ArticleLotteryMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ArticleLotteryMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ArticleLotteryMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ArticleLotteryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArticleLotteryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ArticleLottery entity.
// If the ArticleLottery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleLotteryMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArticleLotteryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArticleLotteryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArticleLotteryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ArticleLottery entity.
// If the ArticleLottery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleLotteryMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArticleLotteryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearArticle clears the "article" edge to the Article entity.
func (m *ArticleLotteryMutation) ClearArticle() {
	m.clearedarticle = true
	m.clearedFields[articlelottery.FieldArticleID] = struct{}{}
}

// ArticleCleared reports if the "article" edge to the Article entity was cleared.
func (m *ArticleLotteryMutation) ArticleCleared() bool {
	return m.clearedarticle
}

// ArticleIDs returns the "article" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArticleID instead. It exists only for internal usage by the builders.
func (m *ArticleLotteryMutation) ArticleIDs() (ids []int) {
	if id := m.article; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArticle resets all changes to the "article" edge.
func (m *ArticleLotteryMutation) ResetArticle() {
	m.article = nil
	m.clearedarticle = false
}

// AddParticipantIDs adds the "participants" edge to the ArticleLotteryParticipant entity by ids.
func (m *ArticleLotteryMutation) AddParticipantIDs(ids ...int) {
	if m.participants == nil {
		m.participants = make(map[int]struct{})
	}
	for i := range ids {
		m.participants[ids[i]] = struct{}{}
	}
}

// ClearParticipants clears the "participants" edge to the ArticleLotteryParticipant entity.
func (m *ArticleLotteryMutation) ClearParticipants() {
	m.clearedparticipants = true
}

// ParticipantsCleared reports if the "participants" edge to the ArticleLotteryParticipant entity was cleared.
func (m *ArticleLotteryMutation) ParticipantsCleared() bool {
	return m.clearedparticipants
}

// RemoveParticipantIDs removes the "participants" edge to the ArticleLotteryParticipant entity by IDs.
func (m *ArticleLotteryMutation) RemoveParticipantIDs(ids ...int) {
	if m.removedparticipants == nil {
		m.removedparticipants = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.participants, ids[i])
		m.removedparticipants[ids[i]] = struct{}{}
	}
}

// RemovedParticipants returns the removed IDs of the "participants" edge to the ArticleLotteryParticipant entity.
func (m *ArticleLotteryMutation) RemovedParticipantsIDs() (ids []int) {
	for id := range m.removedparticipants {
		ids = append(ids, id)
	}
	return
}

// ParticipantsIDs returns the "participants" edge IDs in the mutation.
func (m *ArticleLotteryMutation) ParticipantsIDs() (ids []int) {
	for id := range m.participants {
		ids = append(ids, id)
	}
	return
}

// ResetParticipants resets all changes to the "participants" edge.
func (m *ArticleLotteryMutation) ResetParticipants() {
	m.participants = nil
	m.clearedparticipants = false
	m.removedparticipants = nil
}

// AddWinnerIDs adds the "winners" edge to the ArticleLotteryWinner entity by ids.
func (m *ArticleLotteryMutation) AddWinnerIDs(ids ...int) {
	if m.winners == nil {
		m.winners = make(map[int]struct{})
	}
	for i := range ids {
		m.winners[ids[i]] = struct{}{}
	}
}

// ClearWinners clears the "winners" edge to the ArticleLotteryWinner entity.
func (m *ArticleLotteryMutation) ClearWinners() {
	m.clearedwinners = true
}

// WinnersCleared reports if the "winners" edge to the ArticleLotteryWinner entity was cleared.
func (m *ArticleLotteryMutation) WinnersCleared() bool {
	return m.clearedwinners
}

// RemoveWinnerIDs removes the "winners" edge to the ArticleLotteryWinner entity by IDs.
func (m *ArticleLotteryMutation) RemoveWinnerIDs(ids ...int) {
	if m.removedwinners == nil {
		m.removedwinners = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.winners, ids[i])
		m.removedwinners[ids[i]] = struct{}{}
	}
}

// RemovedWinners returns the removed IDs of the "winners" edge to the ArticleLotteryWinner entity.
func (m *ArticleLotteryMutation) RemovedWinnersIDs() (ids []int) {
	for id := range m.removedwinners {
		ids = append(ids, id)
	}
	return
}

// WinnersIDs returns the "winners" edge IDs in the mutation.
func (m *ArticleLotteryMutation) WinnersIDs() (ids []int) {
	for id := range m.winners {
		ids = append(ids, id)
	}
	return
}

// ResetWinners resets all changes to the "winners" edge.
func (m *ArticleLotteryMutation) ResetWinners() {
	m.winners = nil
	m.clearedwinners = false
	m.removedwinners = nil
}

// Where appends a list predicates to the ArticleLotteryMutation builder.
func (m *ArticleLotteryMutation) Where(ps ...predicate.ArticleLottery) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArticleLotteryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArticleLotteryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ArticleLottery, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArticleLotteryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArticleLotteryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ArticleLottery).
func (m *ArticleLotteryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArticleLotteryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.article != nil {
		fields = append(fields, articlelottery.FieldArticleID)
	}
	if m.prizes != nil {
		fields = append(fields, articlelottery.FieldPrizes)
	}
	if m.start_at != nil {
		fields = append(fields, articlelottery.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, articlelottery.FieldEndAt)
	}
	if m.status != nil {
		fields = append(fields, articlelottery.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, articlelottery.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, articlelottery.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArticleLotteryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case articlelottery.FieldArticleID:
		return m.ArticleID()
	case articlelottery.FieldPrizes:
		return m.Prizes()
	case articlelottery.FieldStartAt:
		return m.StartAt()
	case articlelottery.FieldEndAt:
		return m.EndAt()
	case articlelottery.FieldStatus:
		return m.Status()
	case articlelottery.FieldCreatedAt:
		return m.CreatedAt()
	case articlelottery.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArticleLotteryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case articlelottery.FieldArticleID:
		return m.OldArticleID(ctx)
	case articlelottery.FieldPrizes:
		return m.OldPrizes(ctx)
	case articlelottery.FieldStartAt:
		return m.OldStartAt(ctx)
	case articlelottery.FieldEndAt:
		return m.OldEndAt(ctx)
	case articlelottery.FieldStatus:
		return m.OldStatus(ctx)
	case articlelottery.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case articlelottery.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ArticleLottery field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArticleLotteryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case articlelottery.FieldArticleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArticleID(v)
		return nil
	case articlelottery.FieldPrizes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrizes(v)
		return nil
	case articlelottery.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case articlelottery.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case articlelottery.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case articlelottery.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case articlelottery.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ArticleLottery field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArticleLotteryMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, articlelottery.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArticleLotteryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case articlelottery.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArticleLotteryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case articlelottery.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ArticleLottery numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArticleLotteryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(articlelottery.FieldPrizes) {
		fields = append(fields, articlelottery.FieldPrizes)
	}
	if m.FieldCleared(articlelottery.FieldStartAt) {
		fields = append(fields, articlelottery.FieldStartAt)
	}
	if m.FieldCleared(articlelottery.FieldEndAt) {
		fields = append(fields, articlelottery.FieldEndAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArticleLotteryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArticleLotteryMutation) ClearField(name string) error {
	switch name {
	case articlelottery.FieldPrizes:
		m.ClearPrizes()
		return nil
	case articlelottery.FieldStartAt:
		m.ClearStartAt()
		return nil
	case articlelottery.FieldEndAt:
		m.ClearEndAt()
		return nil
	}
	return fmt.Errorf("unknown ArticleLottery nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArticleLotteryMutation) ResetField(name string) error {
	switch name {
	case articlelottery.FieldArticleID:
		m.ResetArticleID()
		return nil
	case articlelottery.FieldPrizes:
		m.ResetPrizes()
		return nil
	case articlelottery.FieldStartAt:
		m.ResetStartAt()
		return nil
	case articlelottery.FieldEndAt:
		m.ResetEndAt()
		return nil
	case articlelottery.FieldStatus:
		m.ResetStatus()
		return nil
	case articlelottery.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case articlelottery.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ArticleLottery field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArticleLotteryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.article != nil {
		edges = append(edges, articlelottery.EdgeArticle)
	}
	if m.participants != nil {
		edges = append(edges, articlelottery.EdgeParticipants)
	}
	if m.winners != nil {
		edges = append(edges, articlelottery.EdgeWinners)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArticleLotteryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case articlelottery.EdgeArticle:
		if id := m.article; id != nil {
			return []ent.Value{*id}
		}
	case articlelottery.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.participants))
		for id := range m.participants {
			ids = append(ids, id)
		}
		return ids
	case articlelottery.EdgeWinners:
		ids := make([]ent.Value, 0, len(m.winners))
		for id := range m.winners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArticleLotteryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedparticipants != nil {
		edges = append(edges, articlelottery.EdgeParticipants)
	}
	if m.removedwinners != nil {
		edges = append(edges, articlelottery.EdgeWinners)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArticleLotteryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case articlelottery.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.removedparticipants))
		for id := range m.removedparticipants {
			ids = append(ids, id)
		}
		return ids
	case articlelottery.EdgeWinners:
		ids := make([]ent.Value, 0, len(m.removedwinners))
		for id := range m.removedwinners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArticleLotteryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedarticle {
		edges = append(edges, articlelottery.EdgeArticle)
	}
	if m.clearedparticipants {
		edges = append(edges, articlelottery.EdgeParticipants)
	}
	if m.clearedwinners {
		edges = append(edges, articlelottery.EdgeWinners)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArticleLotteryMutation) EdgeCleared(name string) bool {
	switch name {
	case articlelottery.EdgeArticle:
		return m.clearedarticle
	case articlelottery.EdgeParticipants:
		return m.clearedparticipants
	case articlelottery.EdgeWinners:
		return m.clearedwinners
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArticleLotteryMutation) ClearEdge(name string) error {
	switch name {
	case articlelottery.EdgeArticle:
		m.ClearArticle()
		return nil
	}
	return fmt.Errorf("unknown ArticleLottery unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArticleLotteryMutation) ResetEdge(name string) error {
	switch name {
	case articlelottery.EdgeArticle:
		m.ResetArticle()
		return nil
	case articlelottery.EdgeParticipants:
		m.ResetParticipants()
		return nil
	case articlelottery.EdgeWinners:
		m.ResetWinners()
		return nil
	}
	return fmt.Errorf("unknown ArticleLottery edge %s", name)
}

// ArticleLotteryParticipantMutation represents an operation that mutates the ArticleLotteryParticipant nodes in the graph.
type ArticleLotteryParticipantMutation struct {
	config
	op             Op
	typ            string
	id             *int
	user_id        *int
	adduser_id     *int
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	lottery        *int
	clearedlottery bool
	done           bool
	oldValue       func(context.Context) (*ArticleLotteryParticipant, error)
	predicates     []predicate.ArticleLotteryParticipant
}

var _ ent.Mutation = (*ArticleLotteryParticipantMutation)(nil)

// articlelotteryparticipantOption allows management of the mutation configuration using functional options.
type articlelotteryparticipantOption func(*ArticleLotteryParticipantMutation)

// newArticleLotteryParticipantMutation creates new mutation for the ArticleLotteryParticipant entity.
func newArticleLotteryParticipantMutation(c config, op Op, opts ...articlelotteryparticipantOption) *ArticleLotteryParticipantMutation {
	m := &ArticleLotteryParticipantMutation{
		config:        c,
		op:            op,
		typ:           TypeArticleLotteryParticipant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArticleLotteryParticipantID sets the ID field of the mutation.
func withArticleLotteryParticipantID(id int) articlelotteryparticipantOption {
	return func(m *ArticleLotteryParticipantMutation) {
		var (
			err   error
			once  sync.Once
			value *ArticleLotteryParticipant
		)
		m.oldValue = func(ctx context.Context) (*ArticleLotteryParticipant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ArticleLotteryParticipant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArticleLotteryParticipant sets the old ArticleLotteryParticipant of the mutation.
func withArticleLotteryParticipant(node *ArticleLotteryParticipant) articlelotteryparticipantOption {
	return func(m *ArticleLotteryParticipantMutation) {
		m.oldValue = func(context.Context) (*ArticleLotteryParticipant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArticleLotteryParticipantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArticleLotteryParticipantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArticleLotteryParticipantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArticleLotteryParticipantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ArticleLotteryParticipant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLotteryID sets the "lottery_id" field.
func (m *ArticleLotteryParticipantMutation) SetLotteryID(i int) {
	m.lottery = &i
}

// LotteryID returns the value of the "lottery_id" field in the mutation.
func (m *ArticleLotteryParticipantMutation) LotteryID() (r int, exists bool) {
	v := m.lottery
	if v == nil {
		return
	}
	return *v, true
}

// OldLotteryID returns the old "lottery_id" field's value of the ArticleLotteryParticipant entity.
// If the ArticleLotteryParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleLotteryParticipantMutation) OldLotteryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLotteryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLotteryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLotteryID: %w", err)
	}
	return oldValue.LotteryID, nil
}

// ResetLotteryID resets all changes to the "lottery_id" field.
func (m *ArticleLotteryParticipantMutation) ResetLotteryID() {
	m.lottery = nil
}

// SetUserID sets the "user_id" field.
func (m *ArticleLotteryParticipantMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ArticleLotteryParticipantMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ArticleLotteryParticipant entity.
// If the ArticleLotteryParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleLotteryParticipantMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *ArticleLotteryParticipantMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *ArticleLotteryParticipantMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ArticleLotteryParticipantMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ArticleLotteryParticipantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArticleLotteryParticipantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ArticleLotteryParticipant entity.
// If the ArticleLotteryParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleLotteryParticipantMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArticleLotteryParticipantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArticleLotteryParticipantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArticleLotteryParticipantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ArticleLotteryParticipant entity.
// If the ArticleLotteryParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleLotteryParticipantMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArticleLotteryParticipantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearLottery clears the "lottery" edge to the ArticleLottery entity.
func (m *ArticleLotteryParticipantMutation) ClearLottery() {
	m.clearedlottery = true
	m.clearedFields[articlelotteryparticipant.FieldLotteryID] = struct{}{}
}

// LotteryCleared reports if the "lottery" edge to the ArticleLottery entity was cleared.
func (m *ArticleLotteryParticipantMutation) LotteryCleared() bool {
	return m.clearedlottery
}

// LotteryIDs returns the "lottery" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LotteryID instead. It exists only for internal usage by the builders.
func (m *ArticleLotteryParticipantMutation) LotteryIDs() (ids []int) {
	if id := m.lottery; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLottery resets all changes to the "lottery" edge.
func (m *ArticleLotteryParticipantMutation) ResetLottery() {
	m.lottery = nil
	m.clearedlottery = false
}

// Where appends a list predicates to the ArticleLotteryParticipantMutation builder.
func (m *ArticleLotteryParticipantMutation) Where(ps ...predicate.ArticleLotteryParticipant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArticleLotteryParticipantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArticleLotteryParticipantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ArticleLotteryParticipant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArticleLotteryParticipantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArticleLotteryParticipantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ArticleLotteryParticipant).
func (m *ArticleLotteryParticipantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArticleLotteryParticipantMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.lottery != nil {
		fields = append(fields, articlelotteryparticipant.FieldLotteryID)
	}
	if m.user_id != nil {
		fields = append(fields, articlelotteryparticipant.FieldUserID)
	}
	if m.created_at != nil {
		fields = append(fields, articlelotteryparticipant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, articlelotteryparticipant.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArticleLotteryParticipantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case articlelotteryparticipant.FieldLotteryID:
		return m.LotteryID()
	case articlelotteryparticipant.FieldUserID:
		return m.UserID()
	case articlelotteryparticipant.FieldCreatedAt:
		return m.CreatedAt()
	case articlelotteryparticipant.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArticleLotteryParticipantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case articlelotteryparticipant.FieldLotteryID:
		return m.OldLotteryID(ctx)
	case articlelotteryparticipant.FieldUserID:
		return m.OldUserID(ctx)
	case articlelotteryparticipant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case articlelotteryparticipant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ArticleLotteryParticipant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArticleLotteryParticipantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case articlelotteryparticipant.FieldLotteryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLotteryID(v)
		return nil
	case articlelotteryparticipant.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case articlelotteryparticipant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case articlelotteryparticipant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ArticleLotteryParticipant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArticleLotteryParticipantMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, articlelotteryparticipant.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArticleLotteryParticipantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case articlelotteryparticipant.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArticleLotteryParticipantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case articlelotteryparticipant.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown ArticleLotteryParticipant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArticleLotteryParticipantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArticleLotteryParticipantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArticleLotteryParticipantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ArticleLotteryParticipant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArticleLotteryParticipantMutation) ResetField(name string) error {
	switch name {
	case articlelotteryparticipant.FieldLotteryID:
		m.ResetLotteryID()
		return nil
	case articlelotteryparticipant.FieldUserID:
		m.ResetUserID()
		return nil
	case articlelotteryparticipant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case articlelotteryparticipant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ArticleLotteryParticipant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArticleLotteryParticipantMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.lottery != nil {
		edges = append(edges, articlelotteryparticipant.EdgeLottery)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArticleLotteryParticipantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case articlelotteryparticipant.EdgeLottery:
		if id := m.lottery; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArticleLotteryParticipantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArticleLotteryParticipantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArticleLotteryParticipantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlottery {
		edges = append(edges, articlelotteryparticipant.EdgeLottery)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArticleLotteryParticipantMutation) EdgeCleared(name string) bool {
	switch name {
	case articlelotteryparticipant.EdgeLottery:
		return m.clearedlottery
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArticleLotteryParticipantMutation) ClearEdge(name string) error {
	switch name {
	case articlelotteryparticipant.EdgeLottery:
		m.ClearLottery()
		return nil
	}
	return fmt.Errorf("unknown ArticleLotteryParticipant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArticleLotteryParticipantMutation) ResetEdge(name string) error {
	switch name {
	case articlelotteryparticipant.EdgeLottery:
		m.ResetLottery()
		return nil
	}
	return fmt.Errorf("unknown ArticleLotteryParticipant edge %s", name)
}

// ArticleLotteryWinnerMutation represents an operation that mutates the ArticleLotteryWinner nodes in the graph.
type ArticleLotteryWinnerMutation struct {
	config
	op             Op
	typ            string
	id             *int
	user_id        *int
	adduser_id     *int
	prize          *string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	lottery        *int
	clearedlottery bool
	done           bool
	oldValue       func(context.Context) (*ArticleLotteryWinner, error)
	predicates     []predicate.ArticleLotteryWinner
}

var _ ent.Mutation = (*ArticleLotteryWinnerMutation)(nil)

// articlelotterywinnerOption allows management of the mutation configuration using functional options.
type articlelotterywinnerOption func(*ArticleLotteryWinnerMutation)

// newArticleLotteryWinnerMutation creates new mutation for the ArticleLotteryWinner entity.
func newArticleLotteryWinnerMutation(c config, op Op, opts ...articlelotterywinnerOption) *ArticleLotteryWinnerMutation {
	m := &ArticleLotteryWinnerMutation{
		config:        c,
		op:            op,
		typ:           TypeArticleLotteryWinner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArticleLotteryWinnerID sets the ID field of the mutation.
func withArticleLotteryWinnerID(id int) articlelotterywinnerOption {
	return func(m *ArticleLotteryWinnerMutation) {
		var (
			err   error
			once  sync.Once
			value *ArticleLotteryWinner
		)
		m.oldValue = func(ctx context.Context) (*ArticleLotteryWinner, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ArticleLotteryWinner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArticleLotteryWinner sets the old ArticleLotteryWinner of the mutation.
func withArticleLotteryWinner(node *ArticleLotteryWinner) articlelotterywinnerOption {
	return func(m *ArticleLotteryWinnerMutation) {
		m.oldValue = func(context.Context) (*ArticleLotteryWinner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArticleLotteryWinnerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArticleLotteryWinnerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArticleLotteryWinnerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArticleLotteryWinnerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ArticleLotteryWinner.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLotteryID sets the "lottery_id" field.
func (m *ArticleLotteryWinnerMutation) SetLotteryID(i int) {
	m.lottery = &i
}

// LotteryID returns the value of the "lottery_id" field in the mutation.
func (m *ArticleLotteryWinnerMutation) LotteryID() (r int, exists bool) {
	v := m.lottery
	if v == nil {
		return
	}
	return *v, true
}

// OldLotteryID returns the old "lottery_id" field's value of the ArticleLotteryWinner entity.
// If the ArticleLotteryWinner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleLotteryWinnerMutation) OldLotteryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLotteryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLotteryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLotteryID: %w", err)
	}
	return oldValue.LotteryID, nil
}

// ResetLotteryID resets all changes to the "lottery_id" field.
func (m *ArticleLotteryWinnerMutation) ResetLotteryID() {
	m.lottery = nil
}

// SetUserID sets the "user_id" field.
func (m *ArticleLotteryWinnerMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ArticleLotteryWinnerMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ArticleLotteryWinner entity.
// If the ArticleLotteryWinner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleLotteryWinnerMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *ArticleLotteryWinnerMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *ArticleLotteryWinnerMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ArticleLotteryWinnerMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetPrize sets the "prize" field.
func (m *ArticleLotteryWinnerMutation) SetPrize(s string) {
	m.prize = &s
}

// Prize returns the value of the "prize" field in the mutation.
func (m *ArticleLotteryWinnerMutation) Prize() (r string, exists bool) {
	v := m.prize
	if v == nil {
		return
	}
	return *v, true
}

// OldPrize returns the old "prize" field's value of the ArticleLotteryWinner entity.
// If the ArticleLotteryWinner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleLotteryWinnerMutation) OldPrize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrize: %w", err)
	}
	return oldValue.Prize, nil
}

// ResetPrize resets all changes to the "prize" field.
func (m *ArticleLotteryWinnerMutation) ResetPrize() {
	m.prize = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ArticleLotteryWinnerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArticleLotteryWinnerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ArticleLotteryWinner entity.
// If the ArticleLotteryWinner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleLotteryWinnerMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArticleLotteryWinnerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArticleLotteryWinnerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArticleLotteryWinnerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ArticleLotteryWinner entity.
// If the ArticleLotteryWinner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleLotteryWinnerMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArticleLotteryWinnerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearLottery clears the "lottery" edge to the ArticleLottery entity.
func (m *ArticleLotteryWinnerMutation) ClearLottery() {
	m.clearedlottery = true
	m.clearedFields[articlelotterywinner.FieldLotteryID] = struct{}{}
}

// LotteryCleared reports if the "lottery" edge to the ArticleLottery entity was cleared.
func (m *ArticleLotteryWinnerMutation) LotteryCleared() bool {
	return m.clearedlottery
}

// LotteryIDs returns the "lottery" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LotteryID instead. It exists only for internal usage by the builders.
func (m *ArticleLotteryWinnerMutation) LotteryIDs() (ids []int) {
	if id := m.lottery; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLottery resets all changes to the "lottery" edge.
func (m *ArticleLotteryWinnerMutation) ResetLottery() {
	m.lottery = nil
	m.clearedlottery = false
}

// Where appends a list predicates to the ArticleLotteryWinnerMutation builder.
func (m *ArticleLotteryWinnerMutation) Where(ps ...predicate.ArticleLotteryWinner) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArticleLotteryWinnerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArticleLotteryWinnerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ArticleLotteryWinner, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArticleLotteryWinnerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArticleLotteryWinnerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ArticleLotteryWinner).
func (m *ArticleLotteryWinnerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArticleLotteryWinnerMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.lottery != nil {
		fields = append(fields, articlelotterywinner.FieldLotteryID)
	}
	if m.user_id != nil {
		fields = append(fields, articlelotterywinner.FieldUserID)
	}
	if m.prize != nil {
		fields = append(fields, articlelotterywinner.FieldPrize)
	}
	if m.created_at != nil {
		fields = append(fields, articlelotterywinner.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, articlelotterywinner.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArticleLotteryWinnerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case articlelotterywinner.FieldLotteryID:
		return m.LotteryID()
	case articlelotterywinner.FieldUserID:
		return m.UserID()
	case articlelotterywinner.FieldPrize:
		return m.Prize()
	case articlelotterywinner.FieldCreatedAt:
		return m.CreatedAt()
	case articlelotterywinner.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArticleLotteryWinnerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case articlelotterywinner.FieldLotteryID:
		return m.OldLotteryID(ctx)
	case articlelotterywinner.FieldUserID:
		return m.OldUserID(ctx)
	case articlelotterywinner.FieldPrize:
		return m.OldPrize(ctx)
	case articlelotterywinner.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case articlelotterywinner.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ArticleLotteryWinner field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArticleLotteryWinnerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case articlelotterywinner.FieldLotteryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLotteryID(v)
		return nil
	case articlelotterywinner.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case articlelotterywinner.FieldPrize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrize(v)
		return nil
	case articlelotterywinner.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case articlelotterywinner.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ArticleLotteryWinner field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArticleLotteryWinnerMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, articlelotterywinner.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArticleLotteryWinnerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case articlelotterywinner.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArticleLotteryWinnerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case articlelotterywinner.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown ArticleLotteryWinner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArticleLotteryWinnerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArticleLotteryWinnerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArticleLotteryWinnerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ArticleLotteryWinner nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArticleLotteryWinnerMutation) ResetField(name string) error {
	switch name {
	case articlelotterywinner.FieldLotteryID:
		m.ResetLotteryID()
		return nil
	case articlelotterywinner.FieldUserID:
		m.ResetUserID()
		return nil
	case articlelotterywinner.FieldPrize:
		m.ResetPrize()
		return nil
	case articlelotterywinner.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case articlelotterywinner.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ArticleLotteryWinner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArticleLotteryWinnerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.lottery != nil {
		edges = append(edges, articlelotterywinner.EdgeLottery)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArticleLotteryWinnerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case articlelotterywinner.EdgeLottery:
		if id := m.lottery; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArticleLotteryWinnerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArticleLotteryWinnerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArticleLotteryWinnerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlottery {
		edges = append(edges, articlelotterywinner.EdgeLottery)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArticleLotteryWinnerMutation) EdgeCleared(name string) bool {
	switch name {
	case articlelotterywinner.EdgeLottery:
		return m.clearedlottery
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArticleLotteryWinnerMutation) ClearEdge(name string) error {
	switch name {
	case articlelotterywinner.EdgeLottery:
		m.ClearLottery()
		return nil
	}
	return fmt.Errorf("unknown ArticleLotteryWinner unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArticleLotteryWinnerMutation) ResetEdge(name string) error {
	switch name {
	case articlelotterywinner.EdgeLottery:
		m.ResetLottery()
		return nil
	}
	return fmt.Errorf("unknown ArticleLotteryWinner edge %s", name)
}

// ArticlePostscriptMutation represents an operation that mutates the ArticlePostscript nodes in the graph.
type ArticlePostscriptMutation struct {
	config
	op             Op
	typ            string
	id             *int
	content        *string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	article        *int
	clearedarticle bool
	done           bool
	oldValue       func(context.Context) (*ArticlePostscript, error)
	predicates     []predicate.ArticlePostscript
}

var _ ent.Mutation = (*ArticlePostscriptMutation)(nil)

// articlepostscriptOption allows management of the mutation configuration using functional options.
type articlepostscriptOption func(*ArticlePostscriptMutation)

// newArticlePostscriptMutation creates new mutation for the ArticlePostscript entity.
func newArticlePostscriptMutation(c config, op Op, opts ...articlepostscriptOption) *ArticlePostscriptMutation {
	m := &ArticlePostscriptMutation{
		config:        c,
		op:            op,
		typ:           TypeArticlePostscript,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArticlePostscriptID sets the ID field of the mutation.
func withArticlePostscriptID(id int) articlepostscriptOption {
	return func(m *ArticlePostscriptMutation) {
		var (
			err   error
			once  sync.Once
			value *ArticlePostscript
		)
		m.oldValue = func(ctx context.Context) (*ArticlePostscript, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ArticlePostscript.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArticlePostscript sets the old ArticlePostscript of the mutation.
func withArticlePostscript(node *ArticlePostscript) articlepostscriptOption {
	return func(m *ArticlePostscriptMutation) {
		m.oldValue = func(context.Context) (*ArticlePostscript, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArticlePostscriptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArticlePostscriptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArticlePostscriptMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArticlePostscriptMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ArticlePostscript.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArticleID sets the "article_id" field.
func (m *ArticlePostscriptMutation) SetArticleID(i int) {
	m.article = &i
}

// ArticleID returns the value of the "article_id" field in the mutation.
func (m *ArticlePostscriptMutation) ArticleID() (r int, exists bool) {
	v := m.article
	if v == nil {
		return
	}
	return *v, true
}

// OldArticleID returns the old "article_id" field's value of the ArticlePostscript entity.
// If the ArticlePostscript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticlePostscriptMutation) OldArticleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArticleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArticleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArticleID: %w", err)
	}
	return oldValue.ArticleID, nil
}

// ResetArticleID resets all changes to the "article_id" field.
func (m *ArticlePostscriptMutation) ResetArticleID() {
	m.article = nil
}

// SetContent sets the "content" field.
func (m *ArticlePostscriptMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ArticlePostscriptMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the ArticlePostscript entity.
// If the ArticlePostscript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticlePostscriptMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *ArticlePostscriptMutation) ResetContent() {
	m.content = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ArticlePostscriptMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArticlePostscriptMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ArticlePostscript entity.
// If the ArticlePostscript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticlePostscriptMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArticlePostscriptMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArticlePostscriptMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArticlePostscriptMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ArticlePostscript entity.
// If the ArticlePostscript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticlePostscriptMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArticlePostscriptMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearArticle clears the "article" edge to the Article entity.
func (m *ArticlePostscriptMutation) ClearArticle() {
	m.clearedarticle = true
	m.clearedFields[articlepostscript.FieldArticleID] = struct{}{}
}

// ArticleCleared reports if the "article" edge to the Article entity was cleared.
func (m *ArticlePostscriptMutation) ArticleCleared() bool {
	return m.clearedarticle
}

// ArticleIDs returns the "article" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArticleID instead. It exists only for internal usage by the builders.
func (m *ArticlePostscriptMutation) ArticleIDs() (ids []int) {
	if id := m.article; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArticle resets all changes to the "article" edge.
func (m *ArticlePostscriptMutation) ResetArticle() {
	m.article = nil
	m.clearedarticle = false
}

// Where appends a list predicates to the ArticlePostscriptMutation builder.
func (m *ArticlePostscriptMutation) Where(ps ...predicate.ArticlePostscript) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArticlePostscriptMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArticlePostscriptMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ArticlePostscript, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArticlePostscriptMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArticlePostscriptMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ArticlePostscript).
func (m *ArticlePostscriptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArticlePostscriptMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.article != nil {
		fields = append(fields, articlepostscript.FieldArticleID)
	}
	if m.content != nil {
		fields = append(fields, articlepostscript.FieldContent)
	}
	if m.created_at != nil {
		fields = append(fields, articlepostscript.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, articlepostscript.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArticlePostscriptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case articlepostscript.FieldArticleID:
		return m.ArticleID()
	case articlepostscript.FieldContent:
		return m.Content()
	case articlepostscript.FieldCreatedAt:
		return m.CreatedAt()
	case articlepostscript.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArticlePostscriptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case articlepostscript.FieldArticleID:
		return m.OldArticleID(ctx)
	case articlepostscript.FieldContent:
		return m.OldContent(ctx)
	case articlepostscript.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case articlepostscript.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ArticlePostscript field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArticlePostscriptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case articlepostscript.FieldArticleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArticleID(v)
		return nil
	case articlepostscript.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case articlepostscript.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case articlepostscript.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ArticlePostscript field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArticlePostscriptMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArticlePostscriptMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArticlePostscriptMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ArticlePostscript numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArticlePostscriptMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArticlePostscriptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArticlePostscriptMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ArticlePostscript nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArticlePostscriptMutation) ResetField(name string) error {
	switch name {
	case articlepostscript.FieldArticleID:
		m.ResetArticleID()
		return nil
	case articlepostscript.FieldContent:
		m.ResetContent()
		return nil
	case articlepostscript.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case articlepostscript.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ArticlePostscript field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArticlePostscriptMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.article != nil {
		edges = append(edges, articlepostscript.EdgeArticle)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArticlePostscriptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case articlepostscript.EdgeArticle:
		if id := m.article; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArticlePostscriptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArticlePostscriptMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArticlePostscriptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedarticle {
		edges = append(edges, articlepostscript.EdgeArticle)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArticlePostscriptMutation) EdgeCleared(name string) bool {
	switch name {
	case articlepostscript.EdgeArticle:
		return m.clearedarticle
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArticlePostscriptMutation) ClearEdge(name string) error {
	switch name {
	case articlepostscript.EdgeArticle:
		m.ClearArticle()
		return nil
	}
	return fmt.Errorf("unknown ArticlePostscript unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArticlePostscriptMutation) ResetEdge(name string) error {
	switch name {
	case articlepostscript.EdgeArticle:
		m.ResetArticle()
		return nil
	}
	return fmt.Errorf("unknown ArticlePostscript edge %s", name)
}

// ArticleVoteMutation represents an operation that mutates the ArticleVote nodes in the graph.
type ArticleVoteMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	vote_options       *[]string
	appendvote_options []string
	vote_counts        *[]int
	appendvote_counts  []int
	vote_multiple      *bool
	vote_anonymous     *bool
	total_count        *int
	addtotal_count     *int
	end_at             *time.Time
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	article            *int
	clearedarticle     bool
	records            map[int]struct{}
	removedrecords     map[int]struct{}
	clearedrecords     bool
	done               bool
	oldValue           func(context.Context) (*ArticleVote, error)
	predicates         []predicate.ArticleVote
}

var _ ent.Mutation = (*ArticleVoteMutation)(nil)

// articlevoteOption allows management of the mutation configuration using functional options.
type articlevoteOption func(*ArticleVoteMutation)

// newArticleVoteMutation creates new mutation for the ArticleVote entity.
func newArticleVoteMutation(c config, op Op, opts ...articlevoteOption) *ArticleVoteMutation {
	m := &ArticleVoteMutation{
		config:        c,
		op:            op,
		typ:           TypeArticleVote,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArticleVoteID sets the ID field of the mutation.
func withArticleVoteID(id int) articlevoteOption {
	return func(m *ArticleVoteMutation) {
		var (
			err   error
			once  sync.Once
			value *ArticleVote
		)
		m.oldValue = func(ctx context.Context) (*ArticleVote, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ArticleVote.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArticleVote sets the old ArticleVote of the mutation.
func withArticleVote(node *ArticleVote) articlevoteOption {
	return func(m *ArticleVoteMutation) {
		m.oldValue = func(context.Context) (*ArticleVote, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArticleVoteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArticleVoteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArticleVoteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArticleVoteMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ArticleVote.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArticleID sets the "article_id" field.
func (m *ArticleVoteMutation) SetArticleID(i int) {
	m.article = &i
}

// ArticleID returns the value of the "article_id" field in the mutation.
func (m *ArticleVoteMutation) ArticleID() (r int, exists bool) {
	v := m.article
	if v == nil {
		return
	}
	return *v, true
}

// OldArticleID returns the old "article_id" field's value of the ArticleVote entity.
// If the ArticleVote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleVoteMutation) OldArticleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArticleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArticleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArticleID: %w", err)
	}
	return oldValue.ArticleID, nil
}

// ResetArticleID resets all changes to the "article_id" field.
func (m *ArticleVoteMutation) ResetArticleID() {
	m.article = nil
}

// SetVoteOptions sets the "vote_options" field.
func (m *ArticleVoteMutation) SetVoteOptions(s []string) {
	m.vote_options = &s
	m.appendvote_options = nil
}

// VoteOptions returns the value of the "vote_options" field in the mutation.
func (m *ArticleVoteMutation) VoteOptions() (r []string, exists bool) {
	v := m.vote_options
	if v == nil {
		return
	}
	return *v, true
}

// OldVoteOptions returns the old "vote_options" field's value of the ArticleVote entity.
// If the ArticleVote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleVoteMutation) OldVoteOptions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoteOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoteOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoteOptions: %w", err)
	}
	return oldValue.VoteOptions, nil
}

// AppendVoteOptions adds s to the "vote_options" field.
func (m *ArticleVoteMutation) AppendVoteOptions(s []string) {
	m.appendvote_options = append(m.appendvote_options, s...)
}

// AppendedVoteOptions returns the list of values that were appended to the "vote_options" field in this mutation.
func (m *ArticleVoteMutation) AppendedVoteOptions() ([]string, bool) {
	if len(m.appendvote_options) == 0 {
		return nil, false
	}
	return m.appendvote_options, true
}

// ClearVoteOptions clears the value of the "vote_options" field.
func (m *ArticleVoteMutation) ClearVoteOptions() {
	m.vote_options = nil
	m.appendvote_options = nil
	m.clearedFields[articlevote.FieldVoteOptions] = struct{}{}
}

// VoteOptionsCleared returns if the "vote_options" field was cleared in this mutation.
func (m *ArticleVoteMutation) VoteOptionsCleared() bool {
	_, ok := m.clearedFields[articlevote.FieldVoteOptions]
	return ok
}

// ResetVoteOptions resets all changes to the "vote_options" field.
func (m *ArticleVoteMutation) ResetVoteOptions() {
	m.vote_options = nil
	m.appendvote_options = nil
	delete(m.clearedFields, articlevote.FieldVoteOptions)
}

// SetVoteCounts sets the "vote_counts" field.
func (m *ArticleVoteMutation) SetVoteCounts(i []int) {
	m.vote_counts = &i
	m.appendvote_counts = nil
}

// VoteCounts returns the value of the "vote_counts" field in the mutation.
func (m *ArticleVoteMutation) VoteCounts() (r []int, exists bool) {
	v := m.vote_counts
	if v == nil {
		return
	}
	return *v, true
}

// OldVoteCounts returns the old "vote_counts" field's value of the ArticleVote entity.
// If the ArticleVote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleVoteMutation) OldVoteCounts(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoteCounts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoteCounts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoteCounts: %w", err)
	}
	return oldValue.VoteCounts, nil
}

// AppendVoteCounts adds i to the "vote_counts" field.
func (m *ArticleVoteMutation) AppendVoteCounts(i []int) {
	m.appendvote_counts = append(m.appendvote_counts, i...)
}

// AppendedVoteCounts returns the list of values that were appended to the "vote_counts" field in this mutation.
func (m *ArticleVoteMutation) AppendedVoteCounts() ([]int, bool) {
	if len(m.appendvote_counts) == 0 {
		return nil, false
	}
	return m.appendvote_counts, true
}

// ClearVoteCounts clears the value of the "vote_counts" field.
func (m *ArticleVoteMutation) ClearVoteCounts() {
	m.vote_counts = nil
	m.appendvote_counts = nil
	m.clearedFields[articlevote.FieldVoteCounts] = struct{}{}
}

// VoteCountsCleared returns if the "vote_counts" field was cleared in this mutation.
func (m *ArticleVoteMutation) VoteCountsCleared() bool {
	_, ok := m.clearedFields[articlevote.FieldVoteCounts]
	return ok
}

// ResetVoteCounts resets all changes to the "vote_counts" field.
func (m *ArticleVoteMutation) ResetVoteCounts() {
	m.vote_counts = nil
	m.appendvote_counts = nil
	delete(m.clearedFields, articlevote.FieldVoteCounts)
}

// SetVoteMultiple sets the "vote_multiple" field.
func (m *ArticleVoteMutation) SetVoteMultiple(b bool) {
	m.vote_multiple = &b
}

// VoteMultiple returns the value of the "vote_multiple" field in the mutation.
func (m *ArticleVoteMutation) VoteMultiple() (r bool, exists bool) {
	v := m.vote_multiple
	if v == nil {
		return
	}
	return *v, true
}

// OldVoteMultiple returns the old "vote_multiple" field's value of the ArticleVote entity.
// If the ArticleVote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleVoteMutation) OldVoteMultiple(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoteMultiple is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoteMultiple requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoteMultiple: %w", err)
	}
	return oldValue.VoteMultiple, nil
}

// ResetVoteMultiple resets all changes to the "vote_multiple" field.
func (m *ArticleVoteMutation) ResetVoteMultiple() {
	m.vote_multiple = nil
}

// SetVoteAnonymous sets the "vote_anonymous" field.
func (m *ArticleVoteMutation) SetVoteAnonymous(b bool) {
	m.vote_anonymous = &b
}

// VoteAnonymous returns the value of the "vote_anonymous" field in the mutation.
func (m *ArticleVoteMutation) VoteAnonymous() (r bool, exists bool) {
	v := m.vote_anonymous
	if v == nil {
		return
	}
	return *v, true
}

// OldVoteAnonymous returns the old "vote_anonymous" field's value of the ArticleVote entity.
// If the ArticleVote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleVoteMutation) OldVoteAnonymous(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoteAnonymous is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoteAnonymous requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoteAnonymous: %w", err)
	}
	return oldValue.VoteAnonymous, nil
}

// ResetVoteAnonymous resets all changes to the "vote_anonymous" field.
func (m *ArticleVoteMutation) ResetVoteAnonymous() {
	m.vote_anonymous = nil
}

// SetTotalCount sets the "total_count" field.
func (m *ArticleVoteMutation) SetTotalCount(i int) {
	m.total_count = &i
	m.addtotal_count = nil
}

// TotalCount returns the value of the "total_count" field in the mutation.
func (m *ArticleVoteMutation) TotalCount() (r int, exists bool) {
	v := m.total_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCount returns the old "total_count" field's value of the ArticleVote entity.
// If the ArticleVote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleVoteMutation) OldTotalCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCount: %w", err)
	}
	return oldValue.TotalCount, nil
}

// AddTotalCount adds i to the "total_count" field.
func (m *ArticleVoteMutation) AddTotalCount(i int) {
	if m.addtotal_count != nil {
		*m.addtotal_count += i
	} else {
		m.addtotal_count = &i
	}
}

// AddedTotalCount returns the value that was added to the "total_count" field in this mutation.
func (m *ArticleVoteMutation) AddedTotalCount() (r int, exists bool) {
	v := m.addtotal_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalCount resets all changes to the "total_count" field.
func (m *ArticleVoteMutation) ResetTotalCount() {
	m.total_count = nil
	m.addtotal_count = nil
}

// SetEndAt sets the "end_at" field.
func (m *ArticleVoteMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *ArticleVoteMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the ArticleVote entity.
// If the ArticleVote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleVoteMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *ArticleVoteMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[articlevote.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *ArticleVoteMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[articlevote.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *ArticleVoteMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, articlevote.FieldEndAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *ArticleVoteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArticleVoteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ArticleVote entity.
// If the ArticleVote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleVoteMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArticleVoteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArticleVoteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArticleVoteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ArticleVote entity.
// If the ArticleVote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleVoteMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArticleVoteMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearArticle clears the "article" edge to the Article entity.
func (m *ArticleVoteMutation) ClearArticle() {
	m.clearedarticle = true
	m.clearedFields[articlevote.FieldArticleID] = struct{}{}
}

// ArticleCleared reports if the "article" edge to the Article entity was cleared.
func (m *ArticleVoteMutation) ArticleCleared() bool {
	return m.clearedarticle
}

// ArticleIDs returns the "article" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArticleID instead. It exists only for internal usage by the builders.
func (m *ArticleVoteMutation) ArticleIDs() (ids []int) {
	if id := m.article; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArticle resets all changes to the "article" edge.
func (m *ArticleVoteMutation) ResetArticle() {
	m.article = nil
	m.clearedarticle = false
}

// AddRecordIDs adds the "records" edge to the ArticleVoteRecord entity by ids.
func (m *ArticleVoteMutation) AddRecordIDs(ids ...int) {
	if m.records == nil {
		m.records = make(map[int]struct{})
	}
	for i := range ids {
		m.records[ids[i]] = struct{}{}
	}
}

// ClearRecords clears the "records" edge to the ArticleVoteRecord entity.
func (m *ArticleVoteMutation) ClearRecords() {
	m.clearedrecords = true
}

// RecordsCleared reports if the "records" edge to the ArticleVoteRecord entity was cleared.
func (m *ArticleVoteMutation) RecordsCleared() bool {
	return m.clearedrecords
}

// RemoveRecordIDs removes the "records" edge to the ArticleVoteRecord entity by IDs.
func (m *ArticleVoteMutation) RemoveRecordIDs(ids ...int) {
	if m.removedrecords == nil {
		m.removedrecords = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.records, ids[i])
		m.removedrecords[ids[i]] = struct{}{}
	}
}

// RemovedRecords returns the removed IDs of the "records" edge to the ArticleVoteRecord entity.
func (m *ArticleVoteMutation) RemovedRecordsIDs() (ids []int) {
	for id := range m.removedrecords {
		ids = append(ids, id)
	}
	return
}

// RecordsIDs returns the "records" edge IDs in the mutation.
func (m *ArticleVoteMutation) RecordsIDs() (ids []int) {
	for id := range m.records {
		ids = append(ids, id)
	}
	return
}

// ResetRecords resets all changes to the "records" edge.
func (m *ArticleVoteMutation) ResetRecords() {
	m.records = nil
	m.clearedrecords = false
	m.removedrecords = nil
}

// Where appends a list predicates to the ArticleVoteMutation builder.
func (m *ArticleVoteMutation) Where(ps ...predicate.ArticleVote) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArticleVoteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArticleVoteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ArticleVote, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArticleVoteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArticleVoteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ArticleVote).
func (m *ArticleVoteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArticleVoteMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.article != nil {
		fields = append(fields, articlevote.FieldArticleID)
	}
	if m.vote_options != nil {
		fields = append(fields, articlevote.FieldVoteOptions)
	}
	if m.vote_counts != nil {
		fields = append(fields, articlevote.FieldVoteCounts)
	}
	if m.vote_multiple != nil {
		fields = append(fields, articlevote.FieldVoteMultiple)
	}
	if m.vote_anonymous != nil {
		fields = append(fields, articlevote.FieldVoteAnonymous)
	}
	if m.total_count != nil {
		fields = append(fields, articlevote.FieldTotalCount)
	}
	if m.end_at != nil {
		fields = append(fields, articlevote.FieldEndAt)
	}
	if m.created_at != nil {
		fields = append(fields, articlevote.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, articlevote.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArticleVoteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case articlevote.FieldArticleID:
		return m.ArticleID()
	case articlevote.FieldVoteOptions:
		return m.VoteOptions()
	case articlevote.FieldVoteCounts:
		return m.VoteCounts()
	case articlevote.FieldVoteMultiple:
		return m.VoteMultiple()
	case articlevote.FieldVoteAnonymous:
		return m.VoteAnonymous()
	case articlevote.FieldTotalCount:
		return m.TotalCount()
	case articlevote.FieldEndAt:
		return m.EndAt()
	case articlevote.FieldCreatedAt:
		return m.CreatedAt()
	case articlevote.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArticleVoteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case articlevote.FieldArticleID:
		return m.OldArticleID(ctx)
	case articlevote.FieldVoteOptions:
		return m.OldVoteOptions(ctx)
	case articlevote.FieldVoteCounts:
		return m.OldVoteCounts(ctx)
	case articlevote.FieldVoteMultiple:
		return m.OldVoteMultiple(ctx)
	case articlevote.FieldVoteAnonymous:
		return m.OldVoteAnonymous(ctx)
	case articlevote.FieldTotalCount:
		return m.OldTotalCount(ctx)
	case articlevote.FieldEndAt:
		return m.OldEndAt(ctx)
	case articlevote.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case articlevote.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ArticleVote field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArticleVoteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case articlevote.FieldArticleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArticleID(v)
		return nil
	case articlevote.FieldVoteOptions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoteOptions(v)
		return nil
	case articlevote.FieldVoteCounts:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoteCounts(v)
		return nil
	case articlevote.FieldVoteMultiple:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoteMultiple(v)
		return nil
	case articlevote.FieldVoteAnonymous:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoteAnonymous(v)
		return nil
	case articlevote.FieldTotalCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCount(v)
		return nil
	case articlevote.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case articlevote.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case articlevote.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ArticleVote field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArticleVoteMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_count != nil {
		fields = append(fields, articlevote.FieldTotalCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArticleVoteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case articlevote.FieldTotalCount:
		return m.AddedTotalCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArticleVoteMutation) AddField(name string, value ent.Value) error {
	switch name {
	case articlevote.FieldTotalCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCount(v)
		return nil
	}
	return fmt.Errorf("unknown ArticleVote numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArticleVoteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(articlevote.FieldVoteOptions) {
		fields = append(fields, articlevote.FieldVoteOptions)
	}
	if m.FieldCleared(articlevote.FieldVoteCounts) {
		fields = append(fields, articlevote.FieldVoteCounts)
	}
	if m.FieldCleared(articlevote.FieldEndAt) {
		fields = append(fields, articlevote.FieldEndAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArticleVoteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArticleVoteMutation) ClearField(name string) error {
	switch name {
	case articlevote.FieldVoteOptions:
		m.ClearVoteOptions()
		return nil
	case articlevote.FieldVoteCounts:
		m.ClearVoteCounts()
		return nil
	case articlevote.FieldEndAt:
		m.ClearEndAt()
		return nil
	}
	return fmt.Errorf("unknown ArticleVote nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArticleVoteMutation) ResetField(name string) error {
	switch name {
	case articlevote.FieldArticleID:
		m.ResetArticleID()
		return nil
	case articlevote.FieldVoteOptions:
		m.ResetVoteOptions()
		return nil
	case articlevote.FieldVoteCounts:
		m.ResetVoteCounts()
		return nil
	case articlevote.FieldVoteMultiple:
		m.ResetVoteMultiple()
		return nil
	case articlevote.FieldVoteAnonymous:
		m.ResetVoteAnonymous()
		return nil
	case articlevote.FieldTotalCount:
		m.ResetTotalCount()
		return nil
	case articlevote.FieldEndAt:
		m.ResetEndAt()
		return nil
	case articlevote.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case articlevote.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ArticleVote field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArticleVoteMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.article != nil {
		edges = append(edges, articlevote.EdgeArticle)
	}
	if m.records != nil {
		edges = append(edges, articlevote.EdgeRecords)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArticleVoteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case articlevote.EdgeArticle:
		if id := m.article; id != nil {
			return []ent.Value{*id}
		}
	case articlevote.EdgeRecords:
		ids := make([]ent.Value, 0, len(m.records))
		for id := range m.records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArticleVoteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrecords != nil {
		edges = append(edges, articlevote.EdgeRecords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArticleVoteMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case articlevote.EdgeRecords:
		ids := make([]ent.Value, 0, len(m.removedrecords))
		for id := range m.removedrecords {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArticleVoteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedarticle {
		edges = append(edges, articlevote.EdgeArticle)
	}
	if m.clearedrecords {
		edges = append(edges, articlevote.EdgeRecords)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArticleVoteMutation) EdgeCleared(name string) bool {
	switch name {
	case articlevote.EdgeArticle:
		return m.clearedarticle
	case articlevote.EdgeRecords:
		return m.clearedrecords
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArticleVoteMutation) ClearEdge(name string) error {
	switch name {
	case articlevote.EdgeArticle:
		m.ClearArticle()
		return nil
	}
	return fmt.Errorf("unknown ArticleVote unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArticleVoteMutation) ResetEdge(name string) error {
	switch name {
	case articlevote.EdgeArticle:
		m.ResetArticle()
		return nil
	case articlevote.EdgeRecords:
		m.ResetRecords()
		return nil
	}
	return fmt.Errorf("unknown ArticleVote edge %s", name)
}

// ArticleVoteRecordMutation represents an operation that mutates the ArticleVoteRecord nodes in the graph.
type ArticleVoteRecordMutation struct {
	config
	op              Op
	typ             string
	id              *int
	user_id         *int
	adduser_id      *int
	option_index    *int
	addoption_index *int
	anonymous       *bool
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	vote            *int
	clearedvote     bool
	done            bool
	oldValue        func(context.Context) (*ArticleVoteRecord, error)
	predicates      []predicate.ArticleVoteRecord
}

var _ ent.Mutation = (*ArticleVoteRecordMutation)(nil)

// articlevoterecordOption allows management of the mutation configuration using functional options.
type articlevoterecordOption func(*ArticleVoteRecordMutation)

// newArticleVoteRecordMutation creates new mutation for the ArticleVoteRecord entity.
func newArticleVoteRecordMutation(c config, op Op, opts ...articlevoterecordOption) *ArticleVoteRecordMutation {
	m := &ArticleVoteRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeArticleVoteRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArticleVoteRecordID sets the ID field of the mutation.
func withArticleVoteRecordID(id int) articlevoterecordOption {
	return func(m *ArticleVoteRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *ArticleVoteRecord
		)
		m.oldValue = func(ctx context.Context) (*ArticleVoteRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ArticleVoteRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArticleVoteRecord sets the old ArticleVoteRecord of the mutation.
func withArticleVoteRecord(node *ArticleVoteRecord) articlevoterecordOption {
	return func(m *ArticleVoteRecordMutation) {
		m.oldValue = func(context.Context) (*ArticleVoteRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArticleVoteRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArticleVoteRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArticleVoteRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArticleVoteRecordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ArticleVoteRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVoteID sets the "vote_id" field.
func (m *ArticleVoteRecordMutation) SetVoteID(i int) {
	m.vote = &i
}

// VoteID returns the value of the "vote_id" field in the mutation.
func (m *ArticleVoteRecordMutation) VoteID() (r int, exists bool) {
	v := m.vote
	if v == nil {
		return
	}
	return *v, true
}

// OldVoteID returns the old "vote_id" field's value of the ArticleVoteRecord entity.
// If the ArticleVoteRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleVoteRecordMutation) OldVoteID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoteID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoteID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoteID: %w", err)
	}
	return oldValue.VoteID, nil
}

// ResetVoteID resets all changes to the "vote_id" field.
func (m *ArticleVoteRecordMutation) ResetVoteID() {
	m.vote = nil
}

// SetUserID sets the "user_id" field.
func (m *ArticleVoteRecordMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ArticleVoteRecordMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ArticleVoteRecord entity.
// If the ArticleVoteRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleVoteRecordMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *ArticleVoteRecordMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *ArticleVoteRecordMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ArticleVoteRecordMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetOptionIndex sets the "option_index" field.
func (m *ArticleVoteRecordMutation) SetOptionIndex(i int) {
	m.option_index = &i
	m.addoption_index = nil
}

// OptionIndex returns the value of the "option_index" field in the mutation.
func (m *ArticleVoteRecordMutation) OptionIndex() (r int, exists bool) {
	v := m.option_index
	if v == nil {
		return
	}
	return *v, true
}

// OldOptionIndex returns the old "option_index" field's value of the ArticleVoteRecord entity.
// If the ArticleVoteRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleVoteRecordMutation) OldOptionIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptionIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptionIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptionIndex: %w", err)
	}
	return oldValue.OptionIndex, nil
}

// AddOptionIndex adds i to the "option_index" field.
func (m *ArticleVoteRecordMutation) AddOptionIndex(i int) {
	if m.addoption_index != nil {
		*m.addoption_index += i
	} else {
		m.addoption_index = &i
	}
}

// AddedOptionIndex returns the value that was added to the "option_index" field in this mutation.
func (m *ArticleVoteRecordMutation) AddedOptionIndex() (r int, exists bool) {
	v := m.addoption_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetOptionIndex resets all changes to the "option_index" field.
func (m *ArticleVoteRecordMutation) ResetOptionIndex() {
	m.option_index = nil
	m.addoption_index = nil
}

// SetAnonymous sets the "anonymous" field.
func (m *ArticleVoteRecordMutation) SetAnonymous(b bool) {
	m.anonymous = &b
}

// Anonymous returns the value of the "anonymous" field in the mutation.
func (m *ArticleVoteRecordMutation) Anonymous() (r bool, exists bool) {
	v := m.anonymous
	if v == nil {
		return
	}
	return *v, true
}

// OldAnonymous returns the old "anonymous" field's value of the ArticleVoteRecord entity.
// If the ArticleVoteRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleVoteRecordMutation) OldAnonymous(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnonymous is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnonymous requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnonymous: %w", err)
	}
	return oldValue.Anonymous, nil
}

// ResetAnonymous resets all changes to the "anonymous" field.
func (m *ArticleVoteRecordMutation) ResetAnonymous() {
	m.anonymous = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ArticleVoteRecordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArticleVoteRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ArticleVoteRecord entity.
// If the ArticleVoteRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleVoteRecordMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArticleVoteRecordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArticleVoteRecordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArticleVoteRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ArticleVoteRecord entity.
// If the ArticleVoteRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleVoteRecordMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArticleVoteRecordMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearVote clears the "vote" edge to the ArticleVote entity.
func (m *ArticleVoteRecordMutation) ClearVote() {
	m.clearedvote = true
	m.clearedFields[articlevoterecord.FieldVoteID] = struct{}{}
}

// VoteCleared reports if the "vote" edge to the ArticleVote entity was cleared.
func (m *ArticleVoteRecordMutation) VoteCleared() bool {
	return m.clearedvote
}

// VoteIDs returns the "vote" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VoteID instead. It exists only for internal usage by the builders.
func (m *ArticleVoteRecordMutation) VoteIDs() (ids []int) {
	if id := m.vote; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVote resets all changes to the "vote" edge.
func (m *ArticleVoteRecordMutation) ResetVote() {
	m.vote = nil
	m.clearedvote = false
}

// Where appends a list predicates to the ArticleVoteRecordMutation builder.
func (m *ArticleVoteRecordMutation) Where(ps ...predicate.ArticleVoteRecord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArticleVoteRecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArticleVoteRecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ArticleVoteRecord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArticleVoteRecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArticleVoteRecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ArticleVoteRecord).
func (m *ArticleVoteRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArticleVoteRecordMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.vote != nil {
		fields = append(fields, articlevoterecord.FieldVoteID)
	}
	if m.user_id != nil {
		fields = append(fields, articlevoterecord.FieldUserID)
	}
	if m.option_index != nil {
		fields = append(fields, articlevoterecord.FieldOptionIndex)
	}
	if m.anonymous != nil {
		fields = append(fields, articlevoterecord.FieldAnonymous)
	}
	if m.created_at != nil {
		fields = append(fields, articlevoterecord.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, articlevoterecord.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArticleVoteRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case articlevoterecord.FieldVoteID:
		return m.VoteID()
	case articlevoterecord.FieldUserID:
		return m.UserID()
	case articlevoterecord.FieldOptionIndex:
		return m.OptionIndex()
	case articlevoterecord.FieldAnonymous:
		return m.Anonymous()
	case articlevoterecord.FieldCreatedAt:
		return m.CreatedAt()
	case articlevoterecord.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArticleVoteRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case articlevoterecord.FieldVoteID:
		return m.OldVoteID(ctx)
	case articlevoterecord.FieldUserID:
		return m.OldUserID(ctx)
	case articlevoterecord.FieldOptionIndex:
		return m.OldOptionIndex(ctx)
	case articlevoterecord.FieldAnonymous:
		return m.OldAnonymous(ctx)
	case articlevoterecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case articlevoterecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ArticleVoteRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArticleVoteRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case articlevoterecord.FieldVoteID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoteID(v)
		return nil
	case articlevoterecord.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case articlevoterecord.FieldOptionIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptionIndex(v)
		return nil
	case articlevoterecord.FieldAnonymous:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnonymous(v)
		return nil
	case articlevoterecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case articlevoterecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ArticleVoteRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArticleVoteRecordMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, articlevoterecord.FieldUserID)
	}
	if m.addoption_index != nil {
		fields = append(fields, articlevoterecord.FieldOptionIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArticleVoteRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case articlevoterecord.FieldUserID:
		return m.AddedUserID()
	case articlevoterecord.FieldOptionIndex:
		return m.AddedOptionIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArticleVoteRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case articlevoterecord.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case articlevoterecord.FieldOptionIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOptionIndex(v)
		return nil
	}
	return fmt.Errorf("unknown ArticleVoteRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArticleVoteRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArticleVoteRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArticleVoteRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ArticleVoteRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArticleVoteRecordMutation) ResetField(name string) error {
	switch name {
	case articlevoterecord.FieldVoteID:
		m.ResetVoteID()
		return nil
	case articlevoterecord.FieldUserID:
		m.ResetUserID()
		return nil
	case articlevoterecord.FieldOptionIndex:
		m.ResetOptionIndex()
		return nil
	case articlevoterecord.FieldAnonymous:
		m.ResetAnonymous()
		return nil
	case articlevoterecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case articlevoterecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ArticleVoteRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArticleVoteRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.vote != nil {
		edges = append(edges, articlevoterecord.EdgeVote)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArticleVoteRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case articlevoterecord.EdgeVote:
		if id := m.vote; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArticleVoteRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArticleVoteRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArticleVoteRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvote {
		edges = append(edges, articlevoterecord.EdgeVote)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArticleVoteRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case articlevoterecord.EdgeVote:
		return m.clearedvote
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArticleVoteRecordMutation) ClearEdge(name string) error {
	switch name {
	case articlevoterecord.EdgeVote:
		m.ClearVote()
		return nil
	}
	return fmt.Errorf("unknown ArticleVoteRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArticleVoteRecordMutation) ResetEdge(name string) error {
	switch name {
	case articlevoterecord.EdgeVote:
		m.ResetVote()
		return nil
	}
	return fmt.Errorf("unknown ArticleVoteRecord edge %s", name)
}

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op               Op
	typ              string
	id               *int
	user_id          *int
	adduser_id       *int
	content          *string
	level            *int
	addlevel         *int
	status           *int
	addstatus        *int
	reply_count      *int
	addreply_count   *int
	like_count       *int
	addlike_count    *int
	dislike_count    *int
	adddislike_count *int
	collect_count    *int
	addcollect_count *int
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	article          *int
	clearedarticle   bool
	parent           *int
	clearedparent    bool
	replies          map[int]struct{}
	removedreplies   map[int]struct{}
	clearedreplies   bool
	done             bool
	oldValue         func(context.Context) (*Comment, error)
	predicates       []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id int) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArticleID sets the "article_id" field.
func (m *CommentMutation) SetArticleID(i int) {
	m.article = &i
}

// ArticleID returns the value of the "article_id" field in the mutation.
func (m *CommentMutation) ArticleID() (r int, exists bool) {
	v := m.article
	if v == nil {
		return
	}
	return *v, true
}

// OldArticleID returns the old "article_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldArticleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArticleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArticleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArticleID: %w", err)
	}
	return oldValue.ArticleID, nil
}

// ResetArticleID resets all changes to the "article_id" field.
func (m *CommentMutation) ResetArticleID() {
	m.article = nil
}

// SetUserID sets the "user_id" field.
func (m *CommentMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CommentMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *CommentMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *CommentMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CommentMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetContent sets the "content" field.
func (m *CommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *CommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *CommentMutation) ResetContent() {
	m.content = nil
}

// SetLevel sets the "level" field.
func (m *CommentMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *CommentMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *CommentMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *CommentMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *CommentMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetParentID sets the "parent_id" field.
func (m *CommentMutation) SetParentID(i int) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *CommentMutation) ParentID() (r int, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *CommentMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[comment.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *CommentMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *CommentMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, comment.FieldParentID)
}

// SetStatus sets the "status" field.
func (m *CommentMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CommentMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *CommentMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CommentMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CommentMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetReplyCount sets the "reply_count" field.
func (m *CommentMutation) SetReplyCount(i int) {
	m.reply_count = &i
	m.addreply_count = nil
}

// ReplyCount returns the value of the "reply_count" field in the mutation.
func (m *CommentMutation) ReplyCount() (r int, exists bool) {
	v := m.reply_count
	if v == nil {
		return
	}
	return *v, true
}

// OldReplyCount returns the old "reply_count" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldReplyCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReplyCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReplyCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplyCount: %w", err)
	}
	return oldValue.ReplyCount, nil
}

// AddReplyCount adds i to the "reply_count" field.
func (m *CommentMutation) AddReplyCount(i int) {
	if m.addreply_count != nil {
		*m.addreply_count += i
	} else {
		m.addreply_count = &i
	}
}

// AddedReplyCount returns the value that was added to the "reply_count" field in this mutation.
func (m *CommentMutation) AddedReplyCount() (r int, exists bool) {
	v := m.addreply_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetReplyCount resets all changes to the "reply_count" field.
func (m *CommentMutation) ResetReplyCount() {
	m.reply_count = nil
	m.addreply_count = nil
}

// SetLikeCount sets the "like_count" field.
func (m *CommentMutation) SetLikeCount(i int) {
	m.like_count = &i
	m.addlike_count = nil
}

// LikeCount returns the value of the "like_count" field in the mutation.
func (m *CommentMutation) LikeCount() (r int, exists bool) {
	v := m.like_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeCount returns the old "like_count" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldLikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeCount: %w", err)
	}
	return oldValue.LikeCount, nil
}

// AddLikeCount adds i to the "like_count" field.
func (m *CommentMutation) AddLikeCount(i int) {
	if m.addlike_count != nil {
		*m.addlike_count += i
	} else {
		m.addlike_count = &i
	}
}

// AddedLikeCount returns the value that was added to the "like_count" field in this mutation.
func (m *CommentMutation) AddedLikeCount() (r int, exists bool) {
	v := m.addlike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikeCount resets all changes to the "like_count" field.
func (m *CommentMutation) ResetLikeCount() {
	m.like_count = nil
	m.addlike_count = nil
}

// SetDislikeCount sets the "dislike_count" field.
func (m *CommentMutation) SetDislikeCount(i int) {
	m.dislike_count = &i
	m.adddislike_count = nil
}

// DislikeCount returns the value of the "dislike_count" field in the mutation.
func (m *CommentMutation) DislikeCount() (r int, exists bool) {
	v := m.dislike_count
	if v == nil {
		return
	}
	return *v, true
}

// OldDislikeCount returns the old "dislike_count" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldDislikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDislikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDislikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDislikeCount: %w", err)
	}
	return oldValue.DislikeCount, nil
}

// AddDislikeCount adds i to the "dislike_count" field.
func (m *CommentMutation) AddDislikeCount(i int) {
	if m.adddislike_count != nil {
		*m.adddislike_count += i
	} else {
		m.adddislike_count = &i
	}
}

// AddedDislikeCount returns the value that was added to the "dislike_count" field in this mutation.
func (m *CommentMutation) AddedDislikeCount() (r int, exists bool) {
	v := m.adddislike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetDislikeCount resets all changes to the "dislike_count" field.
func (m *CommentMutation) ResetDislikeCount() {
	m.dislike_count = nil
	m.adddislike_count = nil
}

// SetCollectCount sets the "collect_count" field.
func (m *CommentMutation) SetCollectCount(i int) {
	m.collect_count = &i
	m.addcollect_count = nil
}

// CollectCount returns the value of the "collect_count" field in the mutation.
func (m *CommentMutation) CollectCount() (r int, exists bool) {
	v := m.collect_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectCount returns the old "collect_count" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCollectCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectCount: %w", err)
	}
	return oldValue.CollectCount, nil
}

// AddCollectCount adds i to the "collect_count" field.
func (m *CommentMutation) AddCollectCount(i int) {
	if m.addcollect_count != nil {
		*m.addcollect_count += i
	} else {
		m.addcollect_count = &i
	}
}

// AddedCollectCount returns the value that was added to the "collect_count" field in this mutation.
func (m *CommentMutation) AddedCollectCount() (r int, exists bool) {
	v := m.addcollect_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCollectCount resets all changes to the "collect_count" field.
func (m *CommentMutation) ResetCollectCount() {
	m.collect_count = nil
	m.addcollect_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearArticle clears the "article" edge to the Article entity.
func (m *CommentMutation) ClearArticle() {
	m.clearedarticle = true
	m.clearedFields[comment.FieldArticleID] = struct{}{}
}

// ArticleCleared reports if the "article" edge to the Article entity was cleared.
func (m *CommentMutation) ArticleCleared() bool {
	return m.clearedarticle
}

// ArticleIDs returns the "article" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArticleID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) ArticleIDs() (ids []int) {
	if id := m.article; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArticle resets all changes to the "article" edge.
func (m *CommentMutation) ResetArticle() {
	m.article = nil
	m.clearedarticle = false
}

// ClearParent clears the "parent" edge to the Comment entity.
func (m *CommentMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[comment.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Comment entity was cleared.
func (m *CommentMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CommentMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddReplyIDs adds the "replies" edge to the Comment entity by ids.
func (m *CommentMutation) AddReplyIDs(ids ...int) {
	if m.replies == nil {
		m.replies = make(map[int]struct{})
	}
	for i := range ids {
		m.replies[ids[i]] = struct{}{}
	}
}

// ClearReplies clears the "replies" edge to the Comment entity.
func (m *CommentMutation) ClearReplies() {
	m.clearedreplies = true
}

// RepliesCleared reports if the "replies" edge to the Comment entity was cleared.
func (m *CommentMutation) RepliesCleared() bool {
	return m.clearedreplies
}

// RemoveReplyIDs removes the "replies" edge to the Comment entity by IDs.
func (m *CommentMutation) RemoveReplyIDs(ids ...int) {
	if m.removedreplies == nil {
		m.removedreplies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.replies, ids[i])
		m.removedreplies[ids[i]] = struct{}{}
	}
}

// RemovedReplies returns the removed IDs of the "replies" edge to the Comment entity.
func (m *CommentMutation) RemovedRepliesIDs() (ids []int) {
	for id := range m.removedreplies {
		ids = append(ids, id)
	}
	return
}

// RepliesIDs returns the "replies" edge IDs in the mutation.
func (m *CommentMutation) RepliesIDs() (ids []int) {
	for id := range m.replies {
		ids = append(ids, id)
	}
	return
}

// ResetReplies resets all changes to the "replies" edge.
func (m *CommentMutation) ResetReplies() {
	m.replies = nil
	m.clearedreplies = false
	m.removedreplies = nil
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.article != nil {
		fields = append(fields, comment.FieldArticleID)
	}
	if m.user_id != nil {
		fields = append(fields, comment.FieldUserID)
	}
	if m.content != nil {
		fields = append(fields, comment.FieldContent)
	}
	if m.level != nil {
		fields = append(fields, comment.FieldLevel)
	}
	if m.parent != nil {
		fields = append(fields, comment.FieldParentID)
	}
	if m.status != nil {
		fields = append(fields, comment.FieldStatus)
	}
	if m.reply_count != nil {
		fields = append(fields, comment.FieldReplyCount)
	}
	if m.like_count != nil {
		fields = append(fields, comment.FieldLikeCount)
	}
	if m.dislike_count != nil {
		fields = append(fields, comment.FieldDislikeCount)
	}
	if m.collect_count != nil {
		fields = append(fields, comment.FieldCollectCount)
	}
	if m.created_at != nil {
		fields = append(fields, comment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, comment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldArticleID:
		return m.ArticleID()
	case comment.FieldUserID:
		return m.UserID()
	case comment.FieldContent:
		return m.Content()
	case comment.FieldLevel:
		return m.Level()
	case comment.FieldParentID:
		return m.ParentID()
	case comment.FieldStatus:
		return m.Status()
	case comment.FieldReplyCount:
		return m.ReplyCount()
	case comment.FieldLikeCount:
		return m.LikeCount()
	case comment.FieldDislikeCount:
		return m.DislikeCount()
	case comment.FieldCollectCount:
		return m.CollectCount()
	case comment.FieldCreatedAt:
		return m.CreatedAt()
	case comment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldArticleID:
		return m.OldArticleID(ctx)
	case comment.FieldUserID:
		return m.OldUserID(ctx)
	case comment.FieldContent:
		return m.OldContent(ctx)
	case comment.FieldLevel:
		return m.OldLevel(ctx)
	case comment.FieldParentID:
		return m.OldParentID(ctx)
	case comment.FieldStatus:
		return m.OldStatus(ctx)
	case comment.FieldReplyCount:
		return m.OldReplyCount(ctx)
	case comment.FieldLikeCount:
		return m.OldLikeCount(ctx)
	case comment.FieldDislikeCount:
		return m.OldDislikeCount(ctx)
	case comment.FieldCollectCount:
		return m.OldCollectCount(ctx)
	case comment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case comment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldArticleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArticleID(v)
		return nil
	case comment.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case comment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case comment.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case comment.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case comment.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case comment.FieldReplyCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplyCount(v)
		return nil
	case comment.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeCount(v)
		return nil
	case comment.FieldDislikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDislikeCount(v)
		return nil
	case comment.FieldCollectCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectCount(v)
		return nil
	case comment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case comment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, comment.FieldUserID)
	}
	if m.addlevel != nil {
		fields = append(fields, comment.FieldLevel)
	}
	if m.addstatus != nil {
		fields = append(fields, comment.FieldStatus)
	}
	if m.addreply_count != nil {
		fields = append(fields, comment.FieldReplyCount)
	}
	if m.addlike_count != nil {
		fields = append(fields, comment.FieldLikeCount)
	}
	if m.adddislike_count != nil {
		fields = append(fields, comment.FieldDislikeCount)
	}
	if m.addcollect_count != nil {
		fields = append(fields, comment.FieldCollectCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldUserID:
		return m.AddedUserID()
	case comment.FieldLevel:
		return m.AddedLevel()
	case comment.FieldStatus:
		return m.AddedStatus()
	case comment.FieldReplyCount:
		return m.AddedReplyCount()
	case comment.FieldLikeCount:
		return m.AddedLikeCount()
	case comment.FieldDislikeCount:
		return m.AddedDislikeCount()
	case comment.FieldCollectCount:
		return m.AddedCollectCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case comment.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case comment.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case comment.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case comment.FieldReplyCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReplyCount(v)
		return nil
	case comment.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikeCount(v)
		return nil
	case comment.FieldDislikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDislikeCount(v)
		return nil
	case comment.FieldCollectCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCollectCount(v)
		return nil
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(comment.FieldParentID) {
		fields = append(fields, comment.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	switch name {
	case comment.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldArticleID:
		m.ResetArticleID()
		return nil
	case comment.FieldUserID:
		m.ResetUserID()
		return nil
	case comment.FieldContent:
		m.ResetContent()
		return nil
	case comment.FieldLevel:
		m.ResetLevel()
		return nil
	case comment.FieldParentID:
		m.ResetParentID()
		return nil
	case comment.FieldStatus:
		m.ResetStatus()
		return nil
	case comment.FieldReplyCount:
		m.ResetReplyCount()
		return nil
	case comment.FieldLikeCount:
		m.ResetLikeCount()
		return nil
	case comment.FieldDislikeCount:
		m.ResetDislikeCount()
		return nil
	case comment.FieldCollectCount:
		m.ResetCollectCount()
		return nil
	case comment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case comment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.article != nil {
		edges = append(edges, comment.EdgeArticle)
	}
	if m.parent != nil {
		edges = append(edges, comment.EdgeParent)
	}
	if m.replies != nil {
		edges = append(edges, comment.EdgeReplies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeArticle:
		if id := m.article; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.replies))
		for id := range m.replies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedreplies != nil {
		edges = append(edges, comment.EdgeReplies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.removedreplies))
		for id := range m.removedreplies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedarticle {
		edges = append(edges, comment.EdgeArticle)
	}
	if m.clearedparent {
		edges = append(edges, comment.EdgeParent)
	}
	if m.clearedreplies {
		edges = append(edges, comment.EdgeReplies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	switch name {
	case comment.EdgeArticle:
		return m.clearedarticle
	case comment.EdgeParent:
		return m.clearedparent
	case comment.EdgeReplies:
		return m.clearedreplies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	switch name {
	case comment.EdgeArticle:
		m.ClearArticle()
		return nil
	case comment.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	switch name {
	case comment.EdgeArticle:
		m.ResetArticle()
		return nil
	case comment.EdgeParent:
		m.ResetParent()
		return nil
	case comment.EdgeReplies:
		m.ResetReplies()
		return nil
	}
	return fmt.Errorf("unknown Comment edge %s", name)
}

// DomainMutation represents an operation that mutates the Domain nodes in the graph.
type DomainMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	status        *int
	addstatus     *int
	url           *string
	icon          *string
	tag_count     *int
	addtag_count  *int
	is_nav        *bool
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	tags          map[int]struct{}
	removedtags   map[int]struct{}
	clearedtags   bool
	done          bool
	oldValue      func(context.Context) (*Domain, error)
	predicates    []predicate.Domain
}

var _ ent.Mutation = (*DomainMutation)(nil)

// domainOption allows management of the mutation configuration using functional options.
type domainOption func(*DomainMutation)

// newDomainMutation creates new mutation for the Domain entity.
func newDomainMutation(c config, op Op, opts ...domainOption) *DomainMutation {
	m := &DomainMutation{
		config:        c,
		op:            op,
		typ:           TypeDomain,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDomainID sets the ID field of the mutation.
func withDomainID(id int) domainOption {
	return func(m *DomainMutation) {
		var (
			err   error
			once  sync.Once
			value *Domain
		)
		m.oldValue = func(ctx context.Context) (*Domain, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Domain.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDomain sets the old Domain of the mutation.
func withDomain(node *Domain) domainOption {
	return func(m *DomainMutation) {
		m.oldValue = func(context.Context) (*Domain, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DomainMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DomainMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DomainMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DomainMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Domain.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DomainMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DomainMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Domain entity.
// If the Domain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DomainMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *DomainMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DomainMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Domain entity.
// If the Domain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *DomainMutation) ResetDescription() {
	m.description = nil
}

// SetStatus sets the "status" field.
func (m *DomainMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *DomainMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Domain entity.
// If the Domain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *DomainMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *DomainMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *DomainMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetURL sets the "url" field.
func (m *DomainMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *DomainMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Domain entity.
// If the Domain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *DomainMutation) ResetURL() {
	m.url = nil
}

// SetIcon sets the "icon" field.
func (m *DomainMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *DomainMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Domain entity.
// If the Domain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ResetIcon resets all changes to the "icon" field.
func (m *DomainMutation) ResetIcon() {
	m.icon = nil
}

// SetTagCount sets the "tag_count" field.
func (m *DomainMutation) SetTagCount(i int) {
	m.tag_count = &i
	m.addtag_count = nil
}

// TagCount returns the value of the "tag_count" field in the mutation.
func (m *DomainMutation) TagCount() (r int, exists bool) {
	v := m.tag_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTagCount returns the old "tag_count" field's value of the Domain entity.
// If the Domain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainMutation) OldTagCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagCount: %w", err)
	}
	return oldValue.TagCount, nil
}

// AddTagCount adds i to the "tag_count" field.
func (m *DomainMutation) AddTagCount(i int) {
	if m.addtag_count != nil {
		*m.addtag_count += i
	} else {
		m.addtag_count = &i
	}
}

// AddedTagCount returns the value that was added to the "tag_count" field in this mutation.
func (m *DomainMutation) AddedTagCount() (r int, exists bool) {
	v := m.addtag_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetTagCount resets all changes to the "tag_count" field.
func (m *DomainMutation) ResetTagCount() {
	m.tag_count = nil
	m.addtag_count = nil
}

// SetIsNav sets the "is_nav" field.
func (m *DomainMutation) SetIsNav(b bool) {
	m.is_nav = &b
}

// IsNav returns the value of the "is_nav" field in the mutation.
func (m *DomainMutation) IsNav() (r bool, exists bool) {
	v := m.is_nav
	if v == nil {
		return
	}
	return *v, true
}

// OldIsNav returns the old "is_nav" field's value of the Domain entity.
// If the Domain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainMutation) OldIsNav(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsNav is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsNav requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsNav: %w", err)
	}
	return oldValue.IsNav, nil
}

// ResetIsNav resets all changes to the "is_nav" field.
func (m *DomainMutation) ResetIsNav() {
	m.is_nav = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DomainMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DomainMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Domain entity.
// If the Domain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DomainMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DomainMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DomainMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Domain entity.
// If the Domain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DomainMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *DomainMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *DomainMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *DomainMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *DomainMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *DomainMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *DomainMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *DomainMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// Where appends a list predicates to the DomainMutation builder.
func (m *DomainMutation) Where(ps ...predicate.Domain) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DomainMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DomainMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Domain, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DomainMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DomainMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Domain).
func (m *DomainMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DomainMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, domain.FieldName)
	}
	if m.description != nil {
		fields = append(fields, domain.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, domain.FieldStatus)
	}
	if m.url != nil {
		fields = append(fields, domain.FieldURL)
	}
	if m.icon != nil {
		fields = append(fields, domain.FieldIcon)
	}
	if m.tag_count != nil {
		fields = append(fields, domain.FieldTagCount)
	}
	if m.is_nav != nil {
		fields = append(fields, domain.FieldIsNav)
	}
	if m.created_at != nil {
		fields = append(fields, domain.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, domain.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DomainMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case domain.FieldName:
		return m.Name()
	case domain.FieldDescription:
		return m.Description()
	case domain.FieldStatus:
		return m.Status()
	case domain.FieldURL:
		return m.URL()
	case domain.FieldIcon:
		return m.Icon()
	case domain.FieldTagCount:
		return m.TagCount()
	case domain.FieldIsNav:
		return m.IsNav()
	case domain.FieldCreatedAt:
		return m.CreatedAt()
	case domain.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DomainMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case domain.FieldName:
		return m.OldName(ctx)
	case domain.FieldDescription:
		return m.OldDescription(ctx)
	case domain.FieldStatus:
		return m.OldStatus(ctx)
	case domain.FieldURL:
		return m.OldURL(ctx)
	case domain.FieldIcon:
		return m.OldIcon(ctx)
	case domain.FieldTagCount:
		return m.OldTagCount(ctx)
	case domain.FieldIsNav:
		return m.OldIsNav(ctx)
	case domain.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case domain.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Domain field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DomainMutation) SetField(name string, value ent.Value) error {
	switch name {
	case domain.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case domain.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case domain.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case domain.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case domain.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case domain.FieldTagCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagCount(v)
		return nil
	case domain.FieldIsNav:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsNav(v)
		return nil
	case domain.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case domain.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Domain field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DomainMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, domain.FieldStatus)
	}
	if m.addtag_count != nil {
		fields = append(fields, domain.FieldTagCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DomainMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case domain.FieldStatus:
		return m.AddedStatus()
	case domain.FieldTagCount:
		return m.AddedTagCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DomainMutation) AddField(name string, value ent.Value) error {
	switch name {
	case domain.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case domain.FieldTagCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTagCount(v)
		return nil
	}
	return fmt.Errorf("unknown Domain numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DomainMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DomainMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DomainMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Domain nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DomainMutation) ResetField(name string) error {
	switch name {
	case domain.FieldName:
		m.ResetName()
		return nil
	case domain.FieldDescription:
		m.ResetDescription()
		return nil
	case domain.FieldStatus:
		m.ResetStatus()
		return nil
	case domain.FieldURL:
		m.ResetURL()
		return nil
	case domain.FieldIcon:
		m.ResetIcon()
		return nil
	case domain.FieldTagCount:
		m.ResetTagCount()
		return nil
	case domain.FieldIsNav:
		m.ResetIsNav()
		return nil
	case domain.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case domain.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Domain field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DomainMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tags != nil {
		edges = append(edges, domain.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DomainMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case domain.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DomainMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtags != nil {
		edges = append(edges, domain.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DomainMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case domain.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DomainMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtags {
		edges = append(edges, domain.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DomainMutation) EdgeCleared(name string) bool {
	switch name {
	case domain.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DomainMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Domain unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DomainMutation) ResetEdge(name string) error {
	switch name {
	case domain.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Domain edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op               Op
	typ              string
	id               *int
	user_id          *int
	adduser_id       *int
	name             *string
	status           *int
	addstatus        *int
	article_count    *int
	addarticle_count *int
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	article          map[int]struct{}
	removedarticle   map[int]struct{}
	clearedarticle   bool
	domain           *int
	cleareddomain    bool
	done             bool
	oldValue         func(context.Context) (*Tag, error)
	predicates       []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id int) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *TagMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TagMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *TagMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *TagMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TagMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// SetDomainID sets the "domain_id" field.
func (m *TagMutation) SetDomainID(i int) {
	m.domain = &i
}

// DomainID returns the value of the "domain_id" field in the mutation.
func (m *TagMutation) DomainID() (r int, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomainID returns the old "domain_id" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDomainID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomainID: %w", err)
	}
	return oldValue.DomainID, nil
}

// ClearDomainID clears the value of the "domain_id" field.
func (m *TagMutation) ClearDomainID() {
	m.domain = nil
	m.clearedFields[tag.FieldDomainID] = struct{}{}
}

// DomainIDCleared returns if the "domain_id" field was cleared in this mutation.
func (m *TagMutation) DomainIDCleared() bool {
	_, ok := m.clearedFields[tag.FieldDomainID]
	return ok
}

// ResetDomainID resets all changes to the "domain_id" field.
func (m *TagMutation) ResetDomainID() {
	m.domain = nil
	delete(m.clearedFields, tag.FieldDomainID)
}

// SetStatus sets the "status" field.
func (m *TagMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *TagMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *TagMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *TagMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *TagMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetArticleCount sets the "article_count" field.
func (m *TagMutation) SetArticleCount(i int) {
	m.article_count = &i
	m.addarticle_count = nil
}

// ArticleCount returns the value of the "article_count" field in the mutation.
func (m *TagMutation) ArticleCount() (r int, exists bool) {
	v := m.article_count
	if v == nil {
		return
	}
	return *v, true
}

// OldArticleCount returns the old "article_count" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldArticleCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArticleCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArticleCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArticleCount: %w", err)
	}
	return oldValue.ArticleCount, nil
}

// AddArticleCount adds i to the "article_count" field.
func (m *TagMutation) AddArticleCount(i int) {
	if m.addarticle_count != nil {
		*m.addarticle_count += i
	} else {
		m.addarticle_count = &i
	}
}

// AddedArticleCount returns the value that was added to the "article_count" field in this mutation.
func (m *TagMutation) AddedArticleCount() (r int, exists bool) {
	v := m.addarticle_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetArticleCount resets all changes to the "article_count" field.
func (m *TagMutation) ResetArticleCount() {
	m.article_count = nil
	m.addarticle_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddArticleIDs adds the "article" edge to the Article entity by ids.
func (m *TagMutation) AddArticleIDs(ids ...int) {
	if m.article == nil {
		m.article = make(map[int]struct{})
	}
	for i := range ids {
		m.article[ids[i]] = struct{}{}
	}
}

// ClearArticle clears the "article" edge to the Article entity.
func (m *TagMutation) ClearArticle() {
	m.clearedarticle = true
}

// ArticleCleared reports if the "article" edge to the Article entity was cleared.
func (m *TagMutation) ArticleCleared() bool {
	return m.clearedarticle
}

// RemoveArticleIDs removes the "article" edge to the Article entity by IDs.
func (m *TagMutation) RemoveArticleIDs(ids ...int) {
	if m.removedarticle == nil {
		m.removedarticle = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.article, ids[i])
		m.removedarticle[ids[i]] = struct{}{}
	}
}

// RemovedArticle returns the removed IDs of the "article" edge to the Article entity.
func (m *TagMutation) RemovedArticleIDs() (ids []int) {
	for id := range m.removedarticle {
		ids = append(ids, id)
	}
	return
}

// ArticleIDs returns the "article" edge IDs in the mutation.
func (m *TagMutation) ArticleIDs() (ids []int) {
	for id := range m.article {
		ids = append(ids, id)
	}
	return
}

// ResetArticle resets all changes to the "article" edge.
func (m *TagMutation) ResetArticle() {
	m.article = nil
	m.clearedarticle = false
	m.removedarticle = nil
}

// ClearDomain clears the "domain" edge to the Domain entity.
func (m *TagMutation) ClearDomain() {
	m.cleareddomain = true
	m.clearedFields[tag.FieldDomainID] = struct{}{}
}

// DomainCleared reports if the "domain" edge to the Domain entity was cleared.
func (m *TagMutation) DomainCleared() bool {
	return m.DomainIDCleared() || m.cleareddomain
}

// DomainIDs returns the "domain" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DomainID instead. It exists only for internal usage by the builders.
func (m *TagMutation) DomainIDs() (ids []int) {
	if id := m.domain; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDomain resets all changes to the "domain" edge.
func (m *TagMutation) ResetDomain() {
	m.domain = nil
	m.cleareddomain = false
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.user_id != nil {
		fields = append(fields, tag.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.domain != nil {
		fields = append(fields, tag.FieldDomainID)
	}
	if m.status != nil {
		fields = append(fields, tag.FieldStatus)
	}
	if m.article_count != nil {
		fields = append(fields, tag.FieldArticleCount)
	}
	if m.created_at != nil {
		fields = append(fields, tag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tag.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldUserID:
		return m.UserID()
	case tag.FieldName:
		return m.Name()
	case tag.FieldDomainID:
		return m.DomainID()
	case tag.FieldStatus:
		return m.Status()
	case tag.FieldArticleCount:
		return m.ArticleCount()
	case tag.FieldCreatedAt:
		return m.CreatedAt()
	case tag.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldUserID:
		return m.OldUserID(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldDomainID:
		return m.OldDomainID(ctx)
	case tag.FieldStatus:
		return m.OldStatus(ctx)
	case tag.FieldArticleCount:
		return m.OldArticleCount(ctx)
	case tag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldDomainID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomainID(v)
		return nil
	case tag.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tag.FieldArticleCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArticleCount(v)
		return nil
	case tag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, tag.FieldUserID)
	}
	if m.addstatus != nil {
		fields = append(fields, tag.FieldStatus)
	}
	if m.addarticle_count != nil {
		fields = append(fields, tag.FieldArticleCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldUserID:
		return m.AddedUserID()
	case tag.FieldStatus:
		return m.AddedStatus()
	case tag.FieldArticleCount:
		return m.AddedArticleCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tag.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case tag.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case tag.FieldArticleCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddArticleCount(v)
		return nil
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tag.FieldDomainID) {
		fields = append(fields, tag.FieldDomainID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	switch name {
	case tag.FieldDomainID:
		m.ClearDomainID()
		return nil
	}
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldUserID:
		m.ResetUserID()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldDomainID:
		m.ResetDomainID()
		return nil
	case tag.FieldStatus:
		m.ResetStatus()
		return nil
	case tag.FieldArticleCount:
		m.ResetArticleCount()
		return nil
	case tag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.article != nil {
		edges = append(edges, tag.EdgeArticle)
	}
	if m.domain != nil {
		edges = append(edges, tag.EdgeDomain)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeArticle:
		ids := make([]ent.Value, 0, len(m.article))
		for id := range m.article {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeDomain:
		if id := m.domain; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedarticle != nil {
		edges = append(edges, tag.EdgeArticle)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeArticle:
		ids := make([]ent.Value, 0, len(m.removedarticle))
		for id := range m.removedarticle {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedarticle {
		edges = append(edges, tag.EdgeArticle)
	}
	if m.cleareddomain {
		edges = append(edges, tag.EdgeDomain)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeArticle:
		return m.clearedarticle
	case tag.EdgeDomain:
		return m.cleareddomain
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	case tag.EdgeDomain:
		m.ClearDomain()
		return nil
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeArticle:
		m.ResetArticle()
		return nil
	case tag.EdgeDomain:
		m.ResetDomain()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}
